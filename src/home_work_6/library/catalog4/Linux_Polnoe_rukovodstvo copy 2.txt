
   Linux
   Полное руководство
   Введение
   Об этой книге
   Все большую и большую популярность в России и во всем мире завоевывает Linux — UNIX-подобная операционная система для IBM-совместимых персональных компьютеров. Растет количество приложений, разработанных для нее. Постоянно расширяется круг задач, для которых она используется. Из операционной системы для программиста и администратора интернет-сервера она уже превратилась в реальную альтернативу ОС Windows в сфере домашнего и офисного применения.
   Эта книга призвана помочь читателю освоить ОС Linux и научиться полноценно работать в ней. Я предполагаю, что читатель знает, с какой стороны подойти к компьютеру, умеет решать свои прикладные задачи, работая в среде Windows или хотя бы MS DOS, и хочет попробовать на практике операционную систему совсем другого класса, чтобы в дальнейшем, возможно, полностью «пересесть» на нее. Изложение материала происходит последовательно, начиная с этапа установки ОС и заканчивая советами по разработке собственных приложений. Знакомство с операционной системой — соперницей Windows начинается с описания прикладных программ, работающих под ее управлением и предназначенных для решения повседневных задач, стоящих перед пользователем домашнего компьютера: редактирование текста и изображений, работа в Интернете, проигрывание музыки ивидео и т.п. Для облегчения перехода с Windows на Linux в конце книги приведена таблица соответствия популярных Windows-приложений приложениям Linux, разработанным для решения тех же задач. Далее в разделе для пользователя изложены основные сведения о внутренней организации Linux — ядре, файловой системе, процессах и демонах, их взаимодействии, — необходимые для настройки и базового администрирования системы, то есть обслуживания многопользовательской среды, установки программного обеспечения, обеспечения сохранности данных. Собственно сетевому администрированию, то есть настройке различных сетевых служб, посвящен второй раздел книги. И для читателей, знакомых с программированием в среде Windows, предназначен последний раздел, освещающий особенности разработки приложений в ОС Linux и некоторые полезные инструменты разработчика.
   Почему Linux?
   Устанавливая Linux, вы получаете множество преимуществ:
   ? Гибкость.Мало того, что практически все в Linux поддается настройке в соответствии с именно вашими задачами и оборудованием, так вам еще и становятся доступны исходные текстыядра и приложений, и вы можете модифицировать систему так, как вам нужно. Такое можно встретить далеко не в каждой операционной системе, особенно семейства Windows. Вы видели где-нибудь исходные тексты хотя бы Блокнота Windows? Мне, например, очень не хватает функции замены текста в этом редакторе. Для решения этой проблемы я написал собственный редактор, в котором и реализовал эту функцию. А если мне нужно сделать небольшое изменение в ядре? Не буду же я полностью переписывать Windows? Остается только надеяться, что новая функция будет реализована в следующей версии, и ради этой единственной функции устанавливать «монстра», пожирающего еще больше системных ресурсов.
   ? Дешевизна.ОС Linux абсолютно бесплатна. Конечно, компакт-диски с дистрибутивами продаются за деньги, но эти деньги вы платите не за лицензию, а за сам носитель, подбор программного обеспечения на нем и программу-инсталлятор — все, как у пиратов, с той лишь разницей, что это: а) полностью легально, б) гарантированно работает и пользуется технической поддержкой. Вы можете и не покупать дистрибутив, а анонимно и бесплатно выкачать исходные тексты или уже собранные программы из Интернета, установив их самостоятельно и заплатив только за трафик — и это тоже полностью легально. Вам не придется ничего доплачивать, устанавливая Linux на каждый следующий компьютер, не нужно покупать отдельную лицензию на использование Linux на сервере. В любом случае стоимость всего программного обеспечения составит всего несколько долларов. Я не буду сравнивать стоимость построения Linux-сервера со стоимостью аналогичного сервера на платформе Microsoft, вы сами можете это сделать на сайте компании Microsoft.
   ? Простота обслуживания.Сама система и все службы настраиваются путем редактирования конфигурационных файлов. Это обычные текстовые файлы; зная их расположение и формат, вы сможете настроить любой дистрибутив, даже если у вас под рукой нет никаких инструментов, кроме текстового редактора. Кроме того, для облегчения перехода с ОС Windows NT/2000/2003 Server, гдесервисы настраиваются в основном через графический интерфейс, создано множество графических конфигураторов, работа с которыми интуитивно понятна и позволяет сосредоточиться на сути выполняемых действий, а не способе их выполнить.
   ? Нетребовательность к ресурсам.Системные требования зависят от дистрибутива (конкретной реализации Linux) и версии ядра. Существуют дистрибутивы, специально созданные для корректной работы на старых и «бедных» машинах. Например, для организации интернет-сервера на базе дистрибутива Red Hat версии 5.2 вам вполне хватит компьютера с процессором Intel 80486DX и 32 мегабайтами ОЗУ. А окончательно устаревшую 386 машину, на которой никакая современная ОС Windows не запустится, под управлением Linux можно вернуть в строй в качестве маршрутизатора или брандмауэра.
   В чем же причина того, что большинство пользователей до сих пор не рассматривают Linux как полноценную настольную операционную систему? Нет, не в том, что Linux так недружелюбен, как его малюют. И не в том, что под Linux нет ни офисных приложений, ни игр. И не в том, что Linux довольно долго имел проблемы с русским языком. Причина заключается в правильной маркетинговой политике Microsoft — нужно отдать ей должное. Совсем не обязательно создать лучший программный продукт, нужно убедить в том, что он лучше. Это я о Windows (про DOS я вообще молчу — урезанная версия XENIX, которая, в свою очередь является урезанной версией UNIX) — эта операционная система использовала UNIX-решения 20 летней давности, в то время как о существовании самой UNIX некоторые пользователи Windows 95 и не догадывались.
   Задача этой книги — не только научить пользователей работать с Linux, но и развеять мифы о том, что это сложная и неподъемная система, предназначенная только для профессионалов. Если вы читаете эту книгу, то для себя данный миф вы уже почти разрушили. Осталось только чуть-чуть. Вам осталось узнать об истории создания и развития Linux. Ведь о развитии DOS и Windows знают все — об этом написано даже в школьных учебниках по информатике. А про Linux и UNIX в лучшем случае говорят: «Есть такая система».
   История LinuxВсе началось с игры
   Не поверите, но все началось с небольшой игры, написанной Кеном Томпсоном. Но чтобы вам было понятно, при чем здесь игра, нужно сделать небольшой экскурс во времена «до игры».
   В далеком 1965 году начались работы над созданием операционной системой MULTICS (MULTiplexed Information and Computing System) для компьютера GE-645 (об этом компьютере вы точно не прочитаете в школьном учебнике по информатике). Инициатором была компания Bell Laboratories (подразделение компании AT&T),а ее помощниками выступали не менее известные организации — General Electric и Массачусетский технологический институт (МТИ). Что же ожидали от MULTICS? Процессорное время GE-645 стоило очень дорого, поэтому нужна была система разделения процессорного времени, обеспечивающая высокую скорость обработки данных и их совместное использование. Посмотрите на рис. 1 — это система GE-645. Обратите внимание, какое помещение она занимает. А теперь вспомните процессор Intel 80386. К чему это я? Производительность GE-645 чуть выше, чем у процессора 80386. До чего техника дошла (кстати, «шла» она к этому лет эдак 20)! [Картинка: img_1.jpeg] 
   Рис. 1. GE-645© General Electric Information Systems Equipment Division, 1968
   Операционная система Multics была запущена в 1969 году, но она не оправдала возложенных на нее надежд. Поэтому вскоре компания Bell Laboratories прекратила работу над этой системой. Коммерческого успеха эта система не принесла. Правда, для справедливости нужно отметить, что МТИ умудрился продать около 80 инсталляций этой системы, причем некоторые из них «дожили» до начала 90-х годов.
   Но не бывает худа без добра. Multics послужила своеобразным толчком для создания новой операционной системы — UNIX.
   Что же произошло в 1969 году, который считают годом рождения UNIX? Четыре сотрудника Bell Labs, а именно Руд Кенедей (Rudd Canaday), Дуг Мак-Илрой (Doug McIlroy), Дэннис Ричи (Dennis Ritchie) и Кен Томпсон (Ken Thompson) попытались возродить Multics. Все они ранее работали над проектом Multics и не смогли смириться с таким поворотом событий.
   Прежде всего был разработан проект файловой системы — потом эта файловая система стала файловой системой UNIX. Кен Томпсон написал программы, эмулирующие работу файловой системы и режима подкачки. Получилось что-то вроде прототипа ядра новой системы. Это ядро было предназначено для GE-645.
   А сейчас на арене появляется та самая игра — «Космическое путешествие», симулятор полета, написанный Кеном Томпсоном под Multics. Но после прекращения работы над Multicsэту игру оказалось не на чем запускать. Обнаружив в углу лаборатории редко используемую машину PDP-7, Томпсон с Ричи решили переписать игру для нее. Переносить программу на перфоленте оказалось неудобно, и Томпсон разработал для PDP-7 файловую систему, утилиты для работы с файлами и командную оболочку. Все это писалось на машине GEи переносилось на PDP-7 на перфоленте, но, как только был закончен ассемблер для PDP-7, система встала на собственные ноги. Получилась новая операционная система для компьютера PDP-7, которую назвали, по аналогии с Multics, "UNICS" (UNiplexed Information and Computing Service). Такое название ей дал Питер Нейман (Peter Neumann). Кто же переименовал ее в UNIX, до сих пор не известно. [Картинка: img_2.jpeg] 
   Рис. 2. PDP-7
   В то время все программное обеспечение, том числе и операционные системы, писалось на машинно-зависимом языке (ассемблере), то есть если программа, например, написана для компьютера PDP-7, ее нельзя запустить на компьютере с другой архитектурой, например, на GE. Кен Томпсон задался целью сделать универсальную систему, которая могла бы работать на нескольких платформах, то есть создать переносимую, независимую от «железа» операционную систему. Для своей системы он начал разрабатывать язык В, на котором он хотел переписать всю систему. Но «до ума» этот язык довел Дэннис Ричи, обновленная версия языка стала называться С. Да, этот тот самый язык, на котором каждый из нас написал не одну программу. Сейчас мы подходим к созданию той идеологии UNIX'a, которая используется по сей день.
   О работе над новой операционной системы руководство компании Bell Labs ничего не знало. Они думали, что ведущие программисты работают над системой обработки текстов для AT&T.Действительно, Томпсон написал строковый (не текстовый!) редактор ed, который присутствует до сих пор во всех современных дистрибутивах, а Ричи создал программу roff. Новые разработки понравились компании AT&T,которая была заинтересована в дальнейшем развитии проекта и приобрела новый компьютер — PDP-11. Для этого компьютера UNIX был полностью переписан: вся система, включая ядро, была написана на языке С, что позволило переносить систему на другие платформы. На ассемблере была написана только та часть ядра, которая была непосредственно связана с «железом». Это было в 1971 году.Становление UNIX как операционной системы
   Очень много новых функций в ядро системы было добавлено всего за один год — с 1971 по 1972. Система заметно «возмужала» по сравнению с 1969 годом. Теперь она действительно стала похожа на операционную систему. Но система не распространялась — ее использовало только одно подразделение AT&T,Первым шагом системы за пределы компании AT&Tстала установка системы в компании New York Telephone. Система была установлена на компьютере PDP-11/20. обладавшем аж 56 килобайтами оперативной памяти и двумя жесткими дисками по 2,4 Мб каждый, С этого момента началось распространение системы.
   Уже в начале 1973 года насчитывалось 16 инсталляций системы. Это довольно неплохо для времен, когда такую роскошь, как компьютер, могла позволить себе только крупная организация, и то не каждая. Компьютер тогда покупался для решения промышленных задач, а не для набора текста и прослушивания музыки.
   Вот что писал Ричи о UNIX'e:"Мы хотели сохранить не только хорошую среду программирования, в которой можно было решать задачи, но и систему, вокруг которой могло сформироваться товарищество. Мы по опыту знали, что сущностью совместного использования компьютера (the essence of communal computing) является не только замена перфокарточного ввода на терминал, но и предоставление средств и стимулов для более тесного общения, реализуемого средствами удаленного доступа к машине, работающей в режиме разделения времени."
   Летом 1974 года в журнале «Communications of the ACM» появилась первая статья о UNIX. Ее авторами были, как и следовало ожидать, Томпсон и Ричи. Они описывали общее устройство UNIX. В той же статье говорилось, что по состоянию на июль 1974 года система была установлена уже на 600 (!) компьютерах. Вы только вдумайтесь в цифру: количество инсталляций за год возросло более чем в 37 раз. Самое интересно, что система развивалась почти при полном отсутствии поддержки со стороны AT&T.
   После этой статьи операционной системой UNIX заинтересовались многие научно-исследовательские организации. Но AT&Tне имела права заниматься бизнесом, следовательно, система не могла продаваться. Чтобы система все-таки развивалась, Томпсон бесплатно рассылал всем желающим наборы дисков с операционной системой. Такой поворот событий повлек следующую волну развития ОС. Например, студенты Йельского университета разработали командную оболочку (shell), а студенты другого университета создали первую сеть на основе UNIX. В университете Беркли (Калифорния) опять-таки студенты создали огромное количество различных утилит и новую оболочку.
   Если вы читали какую-то литературу по UNIX, то, наверное, знаете, как нумеровались версии UNIX — V1, V2 и т.д. Откуда взялась именно такая нумерация версий? В 1971 году Ричи и Томпсон написали руководство по программированию в UNIX. Версия, которая описывалась в первом издании этого руководства, стала называться V1, далее — V2 и т.д. Если быть предельно точными, то вот даты выхода изданий руководства:
   ? 3 ноября 1971 г. (описывалась версия V1)
   ? 12 июня 1972 г. (описывалась версия V2)
   ? Февраль 1973 г. (V3)
   ? Ноябрь 1973 г. (V4)
   ? Июнь 1974 г. (V5)
   ? Май 1975 г. (V6)
   ? Январь 1979 (V7)
   ? Февраль 1985 г.
   ? Сентябрь 1986 г.
   ? Октябрь 1989 г.
   После 1979 года нумерация Vn больше не использовалась — чуть позже мы с вами узнаем, почему именно.
   Важную роль в развитии UNIX сыграл Калифорнийский университет в Беркли. Как уже было сказано, студенты (точнее, аспиранты) этого университета разработали новую командную оболочку и несколько очень важных утилит. Одной из этих утилит мы пользуемся до сих пор — это текстовый редактор vi (правда, в 1975 году он назывался ex). В том же 1975году Томпсон написал версию Pascal для UNIX.
   Модифицированная в университете Беркли система получила название BSD (Berkeley Software Distribution). Все мы слышали название FreeBSD, некоторые из нас даже работали с этой системой. Так вот, сейчас мы знаем, откуда оно произошло. Данная система содержала Pascal и редактор ex (vi). Университет Беркли имел право заниматься коммерческой деятельностью, поэтому первая версия BSD сначала продавалась по цене $50. Всего было продано 30 копий системы. В 1978 году вышла вторая версия BSD — 2BSD. Вторая версия продавалась активнее — было продано 75 копий. Идеи, разработанные в Беркли, позже были использованы в следующей версии UNIX от Bell Labs.
   Два года спустя Питер Вэйнер (Peter Weiner) и Гейнц Ликлама (Hienz Lycklama) создали компанию Interactive Systems, которая тоже принялась продавать UNIX. Правда, продавалась она под другим именем — Irdis (это первый клон UNIX).
   Вернемся к нумерации Vn. Прекратилась она в 1979 году — в этом году вышла последняя «настоящая» UNIX — UNIX V7. В ее состав входили компилятор С, программы awk, make, uucp, find, cpio и командная оболочка Bourne (и, разумеется, много других программ, которых здесь перечислять нет смысла). Именно эта система была перенесена Дэннисом Ричи и Стивом Джонсоном (оба — сотрудники AT&T)на платформу Interdata, а чуть позже несколько программистов из австралийского университета перенесли ее на платформу Interdata 8. Правда, после переноса на другую платформу немного пострадала производительность системы — за все нужно платить. Университет Беркли занялся решением этой проблемы и решил ее. В 1982 году вышла версия 2.8.1BSD, которая работала значительно быстрее предшествующей.Бурное развитие UNIX
   В 1980 году агентству DARPA (the Defense Advanced Research Projects Agency) потребовалось увеличить мощность компьютеров, на которых базировалась сеть ARPANET (предок сети Интернет). Ресурсы стареньких PDP-10 были уже полностью исчерпаны, поэтому решено было перейти на более мощные компьютеры — VAX. Но для этих компьютеров нужен был стек протоколов TCP/IP. Реализация TCP/IP от DEC отпала по ряду причин, поэтому агентству DARPA ничего другого не оставалось, как выбрать систему BSD. Данный факт положительно отразился на развитии UNIX — ее выбрали основной системой для интернета. [Картинка: img_3.jpeg] 
   Рис. 3. PDP-10 [Картинка: img_4.jpeg] 
   Рис. 4. VAX
   Благодаря тому, что UNIX сделалась основой интернета, темпы ее развития возросли. В начале 80-х вышло много различных версий UNIX. Выпускали их разные компании, по основными конкурентами были компания AT&Tи университет Беркли. Первая выпустила системы Programmer's Workbench (рабочее место программиста) и UNIX System III. Университет Беркли тоже не отставал — с октября 1980 года по сентябрь 1983 года было выпущено 6 версий системы — 4, 4.1, 4.1a, 4.1b, 4.1c, 4.2. Последняя версия отличалась высокопроизводительной файловой системой и встроенной поддержкой сети (TCP/IP). До этого сеть в UNIX поддерживалась, мягко говоря, весьма слабо. Но после реализации стека TCP/IP для UNIX все изменилось. В 1983 году большинство подключенных к интернету компьютеров составляли компьютеры VAX с ОС UNIX.Какие бывают UNIX'ы?
   Как только компании осознали, что на UNIX можно заработать, причем заработать неплохо, на рынке появилось множество клонов UNIX под разными названиями. Например, компания Sun Microsystems (основана в 1982 году, а одним из основателей был автор редактора ex — Билл Джой) перенесла BSD на платформу, разработанную в Стенфорде, чем положила начало новому типу рабочих станций.
   Наверное, вы когда-нибудь слышали об операционных системах IRIX, XENIX, HP-UX — все эти системы UNIX-подобные, их создали, соответственно, компании SGI, SCO, Hewlett-Packard. О XENIX можно вообще долго говорить, но все, что вам нужно знать об этой системе — это то, что она является первым коммерческим UNIX'ом для платформы Intel. ОС IBM HP-UX 1.0 основана на системе System III от AT&T.Кстати, в 1983 году с компании AT&Tбыл снят запрет заниматься компьютерным бизнесом, после чего компания сразу же принялась продавать свою систему System V от Bell Labs (не забываем, что это подразделение AT&T).Выпускала UNIX и компания IBM. Правда, она немного опоздала: продажи ее UNIX — системы AIX — начались только в 1990 году.
   Обилие различных версий UNIX стало причиной так называемых UNIX-войн, когда конкурирующие компании выпускали все новые и новые версии UNIX'a.
   Это далеко не вся история UNIX, но рассмотренного материала вполне хватит, чтобы заполнить пробел в ваших знаниях относительно истории развития этой операционной системы. Если вы заинтересовались, в Интернете есть множество статей, посвященных истории UNIX. Правда, большая их часть написана на английском языке.
   Происхождение LinuxОперационная система Minix
   В 80-х годах мощности персональных компьютеров не хватало для запуска на них ОС UNIX, по к началу 90-х ситуация радикально изменилась. Вычислительные мощности персональных компьютеров достигли нужного уровня, что позволило запускать UNIX на обычном PC. К этому же времени начали появляться версии UNIX для PC. Одной из таких систем была система Minix. Система Minix была разработана в 1987 году Эндрю Таненбаумом (Andrew S. Tannenbaum) как учебная программа: ее назначением была демонстрация устройства и принципа работы реальных операционных систем.
   Поскольку Minix была больше демонстрационной, нежели реальной системой, она была далека от совершенства. К тому же она была ориентирована на процессор 80286, который был более доступным в то время. Исходные коды (12 000 строк) этой операционной системы были опубликованы в книге А. Таненбаума «Операционные системы», которую мог прочитать любой желающий. Одним из читателей этой книги оказался Линус Торвальдс — будущий создатель Linux.Линус Торвальдс
   Линус Бенедикт Торвальдс (Linus Benedict Torvalds) родился 28 декабря 1969 года в г. Хельсинки, Финляндия. Первым компьютером Линуса был Commodore VIC-20, который купил его дед Лео Вальдемар Тёрнквист. Лео Вальдемар был профессором в Университете Хельсинки.
   На «Коммодоре» Линус написал первую программу «Hello, World!». Наверно, все мы начинали именно с этой программы. За 4 года (компьютер был куплен в 1981 году) Линус выжал из него все, что мог, поэтому он стал копить деньги на новый компьютер. Основным источником его доходов в то время были школьные стипендии. В 1987 году он купил компьютер Sinclair QL. Это был очень мощный на то время компьютер. На Sinclair QL был установлен 32-разрядный процессор Motorola 68008 и 128 Кб оперативной памяти. Не удивляйтесь: именно 128 Кб. Это было очень много: для сравнения, на «Коммодоре» было установлено всего 3,5 Кб. На новом компьютере была установлена операционная система Q-DOS.
   За четыре года Линус основательно освоил компьютер и заинтересовался работой операционной системы. В своей книге «Just for fun» он пишет:«Операционками я заинтересовался так: купил флоппи-контроллер, но к нему прилагался такой поганый драйвер, что пришлось написать новый. Пока писал — обнаружил проколы в самой операционной системе или, по крайней мере, несоответствие между тем. что обещала документация, и тем, что реально происходило. Я с этим столкнулся, когдамоя программа отказалась работать.»
   Sinclair QL«прожил» у Линуса 3 года — на год меньше, чем его предшественник. За эти три года Линус написал собственный ассемблер, текстовый редактор и несколько компьютерных игр.
   После школы Линус поступил в Хельсинский университет на факультет компьютерных наук. На первом курсе ему немного не повезло — он вынужден был пойти служить в армию и прослужил там 11 месяцев. После возвращения из армии он продолжил учебу в университете. На втором курсе он прочитал книгу Таненбаума, посвященную операционным системам. Потом Линус писал:«Как только я прочел предисловие, познакомился с концепцией UNIX и узнал, на что способна эта мощная, строгая и красивая операционная система, я захотел купить такой компьютер, на котором сможет работать UNIX. Я решил, что поставлю себе Minix — единственную по-настоящему полезную из известных мне версий.»
   С этого все и началось… [Картинка: img_5.jpeg] 
   Рис. 5.Линус ТорвальдсЛинус недоволен Minix
   В январе 1991 года Линус приобрел в кредит компьютер на базе процессора Intel 80386@33Mhz с 4 мегабайтами оперативной памяти. На компьютер была установлена операционная система Minix. Но установленная система не совсем оправдала его ожидания. Больше всего ему не нравилась программа эмуляции терминала, которая была для него просто необходима — ведь с ее помощью он подключался к университетскому MicroVAX'y. Линус писал:«Беда была в том, что я хотел скачивать и закачивать файлы. То есть мне нужно было уметь писать на диск. Для этого моей программе эмуляции нужен был драйвер дисковода. А еще ей был нужен драйвер файловой системы, чтобы она могла вникать в организацию диска и записывать скачиваемые файлы.... разработка драйверов для дисковода и файловой системы казалась интересным делом. И я решил им заняться. Написал драйвер дисковода. А поскольку я хотел записывать файлы в файловую систему Minix, к тому же этасистема была хорошо документирована, я сделал свою файловую систему совместимой с системой Minix. Таким образом, я мог читать файлы, созданные в Minix, и писать файлы на тот же диск, так что Minix могла читать файлы, созданные моей программой эмуляции терминала»
   Линусу ничего другого не оставалось, как написать собственную программу эмуляции терминала, что он и сделал, как видно из приведенной выше цитаты.
   Кроме отвратительной терминальной программы Линусу не нравилось то, что в Minix нельзя было перевести текущую программу в фоновый режим. После написания своей программы эмуляции терминала Линус фактически взялся за написание своей операционной системы.
   Сначала он принялся писать различные системные вызовы, но эта работа ему быстро надоела — ведь заранее нельзя знать, что именно тебе понадобится. Поэтому он взял оболочку Bourne Again Shell (bash) и попытался запустить ее на своей системе методом научного «тыка» (в математике этот метод называется методом Коши). Он запускал оболочку, онатребовала какой-то системный вызов и завершала свою работу с ошибкой. Линус анализировал, какой вызов был нужен оболочке, и реализовывал его. В 1991 году оболочка все-таки запустилась. Это был очень важный момент в развитии новой ОС: был заложен ее фундамент.
   25августа Линус написал в группу новостей comp.os.minix первое сообщение о создании новой операционной системы. Сохранился даже оригинал этого сообщения:
   From: torvalds@klaava.Helsinki.FI (Linus Benedict Torvalds)
   Newsgroups: comp.os.minix
   Subject: What would you like to see most in minix?
   Summary: small poll for my new operating system
   Message-ID:&lt;1991Aug25.205708.9541@klaava.Helsinki.FI&gt;
   Date: 25 Aug 91 20:57:08 GMT
   Organisation: University of Helsinki

   Hello everybody out there using minix -

   I'm doing a (free) operating system (just a hobby, won't
   be big and professional like gnu) far 386(486) AT clones.
   This has been brewing since april, and is starting to get
   ready. I'd like any feedback on things people like/dislike
   in minix, as my OS resembles it somewhat (same physical
   layout of the file-system (due to practical reasons) among
   other things).

   I've currently ported bash(1.08) and gcc(1.40), and things
   seem to work. This implies that I'll get something prac-
   tical within a few months, and I'd like to know what fea-
   tures most people would want. Any suggestions are welcome,
   but I won't promise I'll implement them :-)

   Linus (torvalds@kruuna.helsinki.fi)

   PS. Yes - it's free of any minix code, and it has a multi-
   threaded fs. It is NOT portable (uses 386 task switching
   etc), and it probably never will support anything other
   than AT-harddisks, as that's all I have :-(.
   Вот перевод этого сообщения:
   From: torvalds@klaava.Helsinki.FI (Linus Benedict Torvalds)
   Newsgroups: comp.os.minix
   Subject:Что вам не хватает в minix?
   Summary:небольшой опрос для новой операционной системы
   Message-ID:&lt;1991Aug25.205708.9541@klaava.Helsinki.FI&gt;
   Date: 25 Aug 91 20:57:08 GMT
   Organization:Университет Хельсинки

   Привет всем пользователям minix

   Я разрабатываю (бесплатную) операционную систему (это
   просто хобби, ничего «огромного» и профессионального вроде
   GNU)для чипов 386(486) AT. Я пишу ее начиная с апреля
   и похоже, что скоро она будет готова. Мне очень важно
   узнать, что вам нравится/не нравится в minix, потому что
   моя ОС напоминает minix (та же самая файловая система (из
   практических соображений) и много еще чего).
   На данный момент я перенес в нее bash(1.08) и gcc(1.40),
   вроде бы они работают. Похоже, что через несколько месяцев
   все будет готово и я хотел бы знать, какие функции вам
   нужны. Принимаются любые заявки, но их выполнение я не
   гарантирую :-)
   Linus (torvalds@kruuna.helsinki.fi)

   PS.Система свободна от кода minix и обладает много-
   потоковой файловой системой. Она не переносима (поскольку
   использует переключение задач 386 и др.) и возможно
   никогда не будет поддерживать ничего, кроме АТ-
   винчестеров, поскольку кроме них у меня ничего нет :-(.
   Версия Linux 0.01 была выпущена 17 сентября 1991 года. В своей книге «Just for fun» Линус пишет:
   «И вот я решился ее выложить. Я не делал публичных объявлений, а просто написал пятерым-десятерым хакерам на личные адреса, что она лежит на FTP-сайте. В числе прочих я написал знаменитому среди фанатов Minix Брюсу Эвансу и Ари Лемке. Я выложил исходники самой Linux и еще несколько бинарников, чтобы можно было хоть что-то делать. Я сказал, что нужно, чтобы запустить все это хозяйство. На машине должна была стоять Minix (версия 386) и нужен был компилятор GCC. Причем на самом деле нужна была моя версия GCC, поэтому ее я тоже выложил.
   Не думаю, чтобы ту версию проверяло больше одного-двух человек. Для этого нужно было возиться с установкой специального компилятора, выделить пустой раздел, чтобы использовать его для загрузки, откомпилировать мое ядро и запустить оболочку. А кроме запуска оболочки, делать было особенно нечего. Можно было распечатать исходники — всего 10 000 строк.
   Я стал распространять свою операционку прежде всего, чтобы доказать, что все это не пустая болтовня — я действительно что-то сделал. В Интернете много болтают. О чем бы ни шла речь — об операционке или о сексе — многие в киберпространстве просто вешают лапшу на уши. Поэтому важно после того как ты растрезвонил, что пишешь операционку, иметь возможность сказать: «Вот — я ее и правда сделал. Я не трепло — можете сами посмотреть».При чем здесь пингвины?
   Кто и когда придумал для новой операционной системы название и логотип? Линус с самого начала хотел назвать свою операционную систему FREAX. Вот и работали бы мы сейчас на FREAX'ax. Если не верите — найдите в Интернете файл kernl/Makefile ядра версии 0.11.
   А название "Linux" получилось следующим образом. Ари Лемке отвел место на FTP-сервере под исходные коды новой системы. Он назвал каталог с новой операционной системой pub/OS/Linux, Впоследствии именно это название за ней и закрепилось.
   А логотип Linux придумали в 1996 году. Тогда в рассылке linux-kernel mailing list прозвучала идея о выборе логотипа для Linux. Сами понимаете, желающих заняться разработкой логотипа — предостаточно, поэтому различных вариантов было много. В процессе обсуждения логотипа Линус сказал, что ему нравятся пингвины. В ответ на это было предложено множество пингвинов в разных позах. Был также вариант пингвина, держащего на руках земной шар. На это Линус ответил:«бедный пингвин не так силен, чтобы удержать земной шар, он, пожалуй, будет раздавлен… Так что если вы думаете о «пингвине», вы должны представлять себе слегка растолстевшего сидящего пингвина, хорошо поевшего и отрыгнувшего. Он сидит с довольной улыбкой — мир кажется прекрасным, если вы только что съели несколько галлонов свежей рыбы…».
   Логотип Linux — полностью соответствует пожеланию Линуса. Логотип создал Ларри Ивинг (Larry Ewing), причем он нарисовал его прямо в Linux с помощью программы GIMP (The GNU Image Manipulation Program). Если вы хорошо знаете зоологию (или хотя бы видели пингвинов по телевизору), то, наверное, заметили, что у настоящих пингвинов клюв и ласты — черные, а у нашего пингвиненка — оранжевые. Это сделано специально, чтобы пингвин был узнаваем. [Картинка: img_6.jpeg] 
   Рис. 6.Символ LinuxПуть к первой версии (1.0)
   Нумерация версий Linux началась с 0.01, и путь к стабильной версии 1.0 занял почти три года.

   Версии ядра Linux до версии 1.0 Таблица 1ВерсияДата выходаОсобенности версии0.0117.09.1991Только ядро, включающее драйвер диска и несколько драйверов устройств. Программ не было. Практически система использоваться не могла0.0326.10.1991В системе уже запускалась командная оболочка и компилятор С. Систему уже можно было использовать и писать в ней новые программы0.1012,1991Система поддерживала AT-жесткий диск. Программы login не было — после загрузки ядра сразу загружалась оболочка bash.0.1112.1991Уже что-то. Эта версия поддерживала FDD, многонациональные клавиатуры, мониторы VGA, EGA, Hercules. Самое главное, что системой начали пользоваться — ее загрузили и установили несколько человек0.1205.01.1992Появилась подкачка — свопинг оперативной памяти на диск. Систему скачало насколько сотен человек. Это первая версия системы, которая распространялась по лицензии GPL0.9604.1992Нет, я не пропустил насколько версий. Просто нумерация была изменена в связи с приближением к стабильной версии. Данная версия позволяла запускать систему X Window — у Linux появился графический интерфейс0.99.1412.1993А вот здесь я пропустил определенное количество подверсий версии 0.99 — их описывать просто нет смысла1.016.04.1994Первая версия! С момента выхода версии 0.01 прошло 2 года и 7 месяцев
   В апреле 1992 года Орест Збровски перенес на Linux систему X Window. Это был настоящий прорыв — но не из-за того, что у Linux появился графический интерфейс, а потому что обмен между X-клиентом и X-сервером осуществлялся с помощью UDS — UNIX Domain Sockets. Coкеты позволили использовать сеть в Linux. Система «повзрослела», что вдохновило Торвальдса на изменение нумерации версий. Вот что он сам пишет но этому поводу: «мы с большим воодушевлением принялись разрабатывать сети для Linux поверх этих самых Domain Sockets, хотя онивовсе не были для этого предназначены. Я был настолько уверен, что все получится, что даже сделал скачок в нумерации версий. В марте 1992 года я планировал выпустить версию 0.13. А вместо этого, получив графический интерфейс пользователя, уверился, что мы на 95% достигли цели — выпуска полноценной, надежной операционной системы, пригодной к тому же для работы в сети. И поэтому выпустил версию 0.95.»
   Разработка сетевой подсистемы — дело довольно сложное. Именно поэтому у версии 0.99 так много подверсий. Версия 1.0 уже могла использоваться в сети.Они создавали Linux
   Линусу помогало много энтузиастов, но на первых порах особенно важен вклад следующих добровольцев:
   ? Вернер Альмесбергер (Werner Almesberger) — разработал драйверы FDD и загрузчик Linux — LILO (Linux LOader);
   ? Теодор Тсо (Theodore Ts'o) — создал файловую систему ext2 (у меня эта файловая система использовалась до конца прошлого года!), библиотеки, распределитель памяти ядра;
   ? Дональд Беккер (Donald Becker) — занимался разработкой сетевых драйверов;
   ? Олаф Кирч (Olaf Kirch) — написал руководство по сетевому администрированию Linux;
   ? Питер Мак-Дональд (Peter McDonald) — разработал поддержку загружаемых модулей в версии 0.99. Правда, в современных версиях ядра этот механизм полностью переделан;
   ? Пол Гортмейкер (Paul Gortmaker) — разработал драйвер RTC (Real Time Clock), несколько сетевых драйверов (в т.ч. NE-2000), написал документы «Linux Ethernet HOWTO» и «Boot-Prompt HOWTO».Первые дистрибутивы
   Если системой заинтересовались, значит, ее нужно распространять. Сейчас Linux распространяется в виде так называемых дистрибутивов. Но первые версии распространялись по-другому. Версии 1991 года помещались на двух дискетах, копии которых можно было скачать с сервера университета в Хельсинки. Первая дискета была загрузочной — наней было ядро. Вторая содержала корневую файловую систему и основные утилиты. Установка и конфигурирование первых версий системы было очень сложным занятием. Установить систему мог только эксперт в UNIX.
   Чтобы упростить процесс установки и настройки системы, были созданы так называемые дистрибутивы. Попробую объяснить «на пальцах», что такое дистрибутив. Предположим, что у нас есть те две дискеты, содержащие ядро и файловую систему. Чтобы превратить «это» в дистрибутив, достаточно еще одной дискеты, на которой будет программа установки системы на компьютер пользователя. Программа установки поможет не только установить, но и настроить основные параметры системы. Современные дистрибутивы кроме самой системы и программы установки содержат еще и набор различных пользовательских программ.
   Первые дистрибутивы появились в 1992 году, когда Линус выпустил ядро Linux по Стандартной Общественной лицензии GNU (GPL). Независимые разработчики (группы программистов)начали выпускать свои дистрибутивы Linux: они разрабатывали программы установки, программы управления пакетами, прикладные программы. Ясно, что каждый дистрибутив выпускался под своим именем.
   Первый дистрибутив, созданный в феврале 1992 года Оуэном Ле Бланк (Owen Le Blanc), назывался MCC Interim Linux (Manchester Computing Centre — Манчестерский компьютерный центр). Любой желающий мог загрузить этот дистрибутив с FTP-сервера MCC. Чуть позже сотрудники университета Техаса разработали дистрибутив TAMU.
   А в октябре 1992 года появился дистрибутив Softlanding Linux System (SLS), созданный Питером Мак-Дональдом (Peter McDonald). Важность этого дистрибутива заключается даже не в том, что этопервый дистрибутив, содержавший систему X Window и поддержку TCP/IP. SLS — это прямой предок всемирно известного дистрибутива Slackware.«Размножение дистрибутивов»
   Можно сказать, что современные дистрибутивы распространяются гак же, как и первые дистрибутивы:
   ? На дискетах (только сейчас вместо дискет используются CD и DVD);
   ? На FTP-сайтах и досках BBS (правда, сейчас из-за большого размера на BBS дистрибутивы не выкладываются).
   С удешевлением CD-ROM дистрибутивы начали распространяться на CD. Первыми компаниями, распространявшими дистрибутивы на CD, были: InfoMagic, Morse Telecommunication, Nascent,Red Hat Software, Trans-Ameritech, Walnut Creekи Yggdrasil Computing Inc. Один CD — намного удобнее двух-трех десятков дискет (средний размер первых дистрибутивов был около 50 Мб). К тому же на CD можно было записать много дополнительной информации: дополнительные программы, коды ядра и приложений, систему X Window, документацию и пр. Диск с дистрибутивом стоит от 20 до 40 долларов, а дистрибутив на дискетах — 20 долларов. Как видите, разница небольшая (если не считать стоимости односкоростного CD-ROM, который тогда стоил 100 долларов).
   Первое, что вы должны помнить о версии дистрибутива — то, что версия дистрибутива почти никогда не совпадает с версией ядра. Например, взять версию дистрибутива Mandrake 10.1 — она содержит версию ядра 2.6. Точно также было и с первыми дистрибутивами: дистрибутив мог называться XXX 2.0 release, но содержать версию ядра 1.0, что создавало определенную путаницу.
   О дистрибутивах можно говорить очень долго. Сегодня существует три основных дистрибутива: Red Hat, Slackware и Debian. Все остальные дистрибутивы являются производными от этих трех дистрибутивов. На наших просторах более популярны RH-совместимые дистрибутивы (Mandrake, ALT Linux, ASP Linux), поэтому мы остановимся только на этих дистрибутивах, точнее только на дистрибутиве Red Hat, поскольку, если описывать историю каждого (или более или менее известного) дистрибутива, можно написать книгу толще, чем та, которую выдержите в руках.
   Компания Red Hat была основана Марком Ивингом (Marc Ewing) в 1994 году, а в 1995 году была куплена компанией АСС Bookstores, принадлежавшей Бобу Янгу (Bob Young). Дистрибутивы от Red Hat пользовались большой популярностью, поскольку они были достаточно надежны (их смело можно было устанавливать даже на серверы), обладали удобной программой установки и удобными средствами конфигурирования системы. Red Hat — это самая большая коммерческая компания, которая занимается только ОС Linux.
   Давайте рассмотрим этапы развития дистрибутивов Red Hat (источником информации послужил сайт компании Red Hat — http://fedora.redhat.com/about/history/).

   История дистрибутивов Red Hat Таблица 2ДатаВерсииОписание29июля 1994Просто бета-версияПервая бета-версия, основанная на ядра версии 1.1.18 и системе управления пакетами RPP (разработка Red hat). Данная версия поставлялась на CD, на котором кроме всего прочегопоставлялась полная документация к этой системе. Не получила широкого распространения. Данная версия называлась «Red Hat Software Linux»31октября 1994RHL 0.9 (Halloween)Первая бета-версия, получившая широкое распространение. Пользователи могли выбрать два ядра — стабильное (1.0.9) или экспериментальное (1.1.54). В этой версии появился графический интерфейс к программе rpp — LIM (Linux Installation Manager). Кроме LIM в этой версии появились графические программы настройки ОС: управления пользователями и группами, файлом fstab и сетьюмай 1995RHL 1.0 (Mother's Day)Первый релиз (не бета-версия). Построена на ядре 1.2.8. В документации она называлась не "Red Hat Software Linux", a «Red Hat Commercial Linux». Очевидно, изменение название произошло после покупки компании Rad Hal фирмой АСС Bookstores. Логотип этой версии содержал «красную шляпу» — на логотипе был изображен мужчина, несущий в одной руке красную шляпу, а в другой — портфельАвгуст 1995RHL 2.0 betaОтличительная особенность этой версии — поддержка формата исполнимых файлов ELF (Executable Linkage Format), до этого использовался формат "a.out". Система управления пакетами RPP была заменена системой RPM. в результате чего была полностью не совместима с предыдущими версиями20сентября 1995RHL 2.0То же самое, но не бета-версия. Дистрибутив использует систему RPM23ноября 1996RHL 2.1В этой версии были исправлены некоторые ошибки предыдущей. На основе этой версии компания Digital создала диск «Red Hat 2.1 LINUX» (для x86-компьютеров), который послужил основой для созданий RH для платформы Alpha («Red Hat Linux/Alpha 2.1»)Март 15, 1996RHL 3.0.3 (Picasso)Первая многоплатформенная версия. Поддерживались архитектуры x86 и Alpha. Для Альфы использовался формат исполнимых файлов a.out, а для x86 — ELF. В этой версии появился X-сервер Metro-X, утилита настройки принтера и оболочка glint для программы rpm.июль-август 1996RHL 3.0.4/3.95 (Rembrandt)Система RPM переписана на С (до этого она была написана на Perl). Появились новые средства конфигурирования, модуль РАМ (Pluggable Authentication Modules). Благодаря переходу на ядро версии 2.0 появилась возможность использовать модули ядра, а до этого на дисках дистрибутива RH поставлялось 72 варианта ядер, из которых пользователь должен был выбрать наиболее подходящее его «железу»3октября 1996RHL 4.0 (Colgate)Ядро — 2.0.1B. Поддерживаются уже три архитектуры: x86, Alpha и SPARC. Впервые на Alpha используется формат ELF. Изменен логотип дистрибутива, который используется до сих пор — $$$intro.tif3февраля 1997RHL 4.1 (Vanderbilt)Исправляла ошибки предыдущей версии19мая 1997RHL 4.2 (Biltmore)Отличалась использованием стабильной, хотя и устаревшей, версии libc 5.3. Использование устаревшей версии себя оправдало: в версии 5.4 обнаружилось очень много ошибок27августа– 16 сентября 1997RHL 4.8/4.8.1/4.95 (Thunderbird)Использовалась библиотека glibc 2.0.7–16 октября 1997RHL 4.9/4.9.1/4.96 (Mustang)Исправлены ошибки, связанные с переходом на другую версию C-библиотек (с libc на glibc)1декабря 1997RHL 5.0 (Hurricane)Этот дистрибутив включал программу резервного копирования ВRU2000-РЕ™ и клиент для Real Audio™1июня 1998RHL 5.1 (Manhattan)Особенности этого дистрибутива; графическая среда GNOME (но не устанавливалась по умолчанию), единая утилита конфигурации — linuxconf, браузер Netscape (до этого использовался браузер Red Baron, содержавший много ошибок).12октября 1998RHL 5.2 (Apollo)–17марта 1999RHL 5.9 (Starbuck)–19апреля 1999RHL 6.0 (Hedwig)Среда GNOME наконец-то интегрирована в дистрибутив. Ядро 2.2, glibs 2.1.Это первый мой RH-дистрибутив. Запомнился как отличный стабильный дистрибутив. У меня до сих пор есть компакт-диск с этим дистрибутивом.6сентября 1999RHL 6.0.50 (Lorax)Новый инсталлятор системы anaconda мог работать как в текстовом, так и графическом режимах.4октября 1999RHL 6.1 (Cartman)-27марта 2000RHL 6.2 (Zoot)ISO-образы этой версии были доступны на FTP-сервере Red Hat25сентября 2000RHL 7.0 (Guinness)Б составе дистрибутива была новая версия библиотеки glibc 2.2 и последняя версия gcc 2.96. Включение версии gcc 2.96 не было согласовано с разработчиками gcc, что вызвало небольшой конфликт между ними и компанией Red Hat31января 2001RHL 7.0.90 (Fisher)Первая версия, использующая ядро 2.416апреля 2001RHL 7.1 (Seawolf)Впервые появилась поддержка большого количества языков (дистрибутив поддерживал даже китайский и японский языки). Вместе с Netscape поставлялся браузер Mozilla2-21августа 2001RHL 7.1.93, 7.1.94 (Roswell)По умолчанию использовалась новая версия файловой системы — ext3 вместо ехt2. А вместо LILO начал использоваться загрузчик GRUB. Хотя при установке можно было выбрать LILO, если GRUB пользователю не нравился22октября 2001RHL 7.2 (Enigma)Довольно неплохая версия, она «прожила» на моем компьютере до версии 7.3. Правда, в ней были некоторые ошибки, которые были исправлены в версии 7.3. Особенности: GNOME 1.4, KDE 2.2. Послужила основой для дистрибутива Red Hat Enterprise Linux 2.1 AS (Advanced Server).22марта 2002RHL 7.2.91 (Skipjack)–6мая 2002RHL 7.3 (Valhalla)Выход версии 7.3 не планировался — сразу должна была выйти версия 8.0. Поэтому версию 7.3 нужно рассматривать как «переходную» версию. В версии 8.0 должны быть gcc3, GTK+ 2, Python 2 и другие новые версии инструментальных средств. Но они «опаздывали» к запланированному сроку выпуска версии 8.0, поэтому было решено выпуск версии 8.0 немного отложить, а вместо нее выпустить версию 7.3 без всех этих нововведений. Но в версии 7.3 все же были исправлены некоторые ошибки версии 7.2. Я лично работал с этим дистрибутивом, и он мне понравился даже больше, чем 8.0. Это последний дистрибутив, содержавший браузер Netscape6мая 2002RHEL 2.1 AS (Pensacola)Red Hal Enterprise Linux 2.1 AS— дистрибутив, предназначенный для корпоративного применения. Его основа — дистрибутив RH 7.230сентября 2002RHL 8.0 (Psyche)В этой версии были gcc 3.2, glibc 2.3, GNOME 2, KDE 3.0.3 и OpenOffice.org 1.0.131марта 2003RHL 9 (Shrike)Основан на ядре 2.4.20 с поддержкой NPTL (Native POSIX Thread Library). Послужил основой для Red Hat Enterprise Linux 321июля 2003RHL 9.0.93 (Severn)Это последняя версия «Красной Шапочки» — после этого дистрибутивы стали называться Fedora Core (для настольных систем) и RHEL (для корпоративного применения). Fedora Core — это открытый (читайте — бесплатный) проект, a RHEL — коммерческий проект от RH25сентября 2003FC 0.94 (Severn)Пробная версия Fedora Core13октября 2003FC 0.95 (Severn)Первый дистрибутив от RH, использующий репозиторий yum для обновления системы22октября 2003RHEL 3 (Taroon)Red Hat Enterprise Linux 3поддерживал одновременно 7 архитектур: Intel x86, Intel Itanium, AMD AMD64, IBM zSeries, IBM iSeries, IBM pSeries и IBM S/390. Основан на ядре 2.4.215ноября 2003FC 1 (Yarrow)Первый релиз Fedora Core, используется пока что ядро 2.4 — в последний раз12февраля; 29 марта; 27 апреля 2004FC 1.90, 1.91, 1.92Первые версии, использующее ядро 2.6. Поддерживаются архитектуры x86 и x86-645марта 2004FC 1 (Yarrow)Fedora Core 1для x86-6418мая 2004FC 2 (Tettnang)Второй релиз Fedora Core; KDE 3.2, GNOME 2.68ноября 2004FC3 (Heidelberg)Третий релиз Fedora Core. GNOME 2.8 и KDE 3.3. Довольно «глючное» создание, до недавнего времени обитавшее на моем компьютере13июня 2005FC 4 (Stentz)Четвертый релиз Fedora Core. GNOME 2.10 и KDE 3.4 Довольно много нововведений
   Дистрибутив Red Hat Linux имеет множество потомков — производных дистрибутивов, которые основаны на RH и практически полностью с ним совместимы. Самыми известными потомками RH являются:
   ? Linux Mandrake (версия MDK 5.1 была основана на RH 5.1) — а на MDK основан ALT Linux;
   ? Black Cat (Версия BC 5.2 основана на RH 5.2) — впоследствии BC перерос в ASP Linux.
   Выбор дистрибутива
   Итак, дистрибутив — это ядро + системные утилиты + заранее подготовленный пакет программного обеспечения, снабженный удобной программой-инсталлятором.
   Строго говоря, название Linux принадлежит только ядру. Другие компоненты ОС Linux и прикладные программы для нее разрабатываются не какой-то одной компанией, а независимыми группами программистов, работающих на условиях Стандартной Общественной Лицензии (General Public License; ее русский перевод можно прочитать по адресуhttp://rus-linux.net/MyLDP/histori/gpl/gplrus.html).Эта лицензия обязывает ее держателя бесплатно предоставлять исходный код распространяемого им программного обеспечения, так что теоретически каждый может легально скачать с публичного сервера тексты программ, скомпилировать и собрать их на своем компьютере и получить готовую к установке операционную систему.
   Если вы решитесь собрать Linux с нуля, то прочитать руководство можно по адресуwww.linuxfromscratch.org (русский перевод:multilinux.sakh.com).Если нет — то покупайте дистрибутив. Необходимость платить деньги вовсе не противоречит некоммерческой идеологии Linux; поставщик дистрибутива продает не код, а только услуги по его записи на носитель, доставке, установке, технической поддержке и т.п.
   На сегодня существуют и поддерживаются разработчиками сотни разных дистрибутивов, различающихся по области применения, версии ядра, составу включенных в них прикладных программ, требованиям к аппаратному обеспечению и другим признакам. Классификации этого многообразия посвящены статьи В.Костромина и А.Федорчука в Библиотеке ЛинуксЦентра по адресуwww.linuxcenter.ru/lib/articles/distrib.
   Можно с уверенностью утверждать, что каждый начинающий пользователь Linux столкнется или уже столкнулся с проблемой выбора среди такого изобилия. Какой дистрибутивлучше? Чем отличается Red Hat от Mandrake? Некоторых начинающих пользователей этой замечательной ОС вводят в заблуждение имена дистрибутивов, например, LinuxXP. Вот они его ипокупают, а потом полностью разочаровываются в Linux. Не скажу, что LinuxXP очень плохой дистрибутив, но у начинающего пользователя будет меньше проблем с полной, а не облегченной, версией какого-нибудь «серьезного» дистрибутива, например, Linux Mandrake или Fedora Core.
   Сейчас я попытаюсь помочь читателю выбрать дистрибутив, с которого можно начать свое знакомство с Linux.
   Прежде всего нужно определиться, для чего вам нужен Linux. Хотите ли вы глубоко изучать эту операционную систему? Или, быстро освоив ее, заменить ею Windows в своем офисе, чтобы избежать визитов «борцов с компьютерным пиратством»? Или, может быть, вам нужно настроить сервер для выхода вашей локальной сети в Интернет? Многие компании выпускают дистрибутивы, адаптированные под любое из указанных применений.
   Следующий вопрос — совместимость с имеющимся у вас оборудованием: установится ли выбранный дистрибутив на ваш компьютер? А если установится, то не откажется ли работать, например, с модемом? Не секрет, что долгое время разрыв по количеству поддерживаемых устройств между Windows и Linux был попросту вопиющим. Сегодня ситуация значительно выровнялась. Нынешние дистрибутивы неплохо распознают современное оборудование — процессоры, чипсеты, IDE-, SCSI- и USB-устройства. Практически наверняка не возникнет проблем даже с TV-тюнерами и приводами CD-RW.
   Правда, почти у всех дистрибутивов не сложились отношения с Windows-модемами. Ситуация обусловлена тем, что производители не спешат предоставить информацию по своим продуктам для создания Linux-драйверов. Первая попытка поддержки Windows-модема была сделана компанией ALT Linux, на сайте которой есть пакет hsf, обеспечивающий работу устройств на чипе Connexant. В Интернете можно также поискать драйверы для других модемов, скажем, Motorola.
   Примерно то же самое относится и к GDI-принтерам. Их производители неохотно поддерживают Linux, во многих случаях приходится надеяться исключительно на энтузиастов. Относительно благополучно дела обстоят разве что с оборудованием компании Oki.
   В целом же ситуацию с аппаратным обеспечением можно подытожить таким образом: со «средним» оборудованием, не слишком старым и не самым новым, существенных проблемвозникнуть не должно. Для новейших, дорогих и «навороченных» устройств могут поддерживаться лишь их базовые функции, то есть деньги, заплаченные вами за усовершенствования, окажутся потрачены впустую. Поэтому стоит предварительно изучить список совместимых устройств и базовую комплектацию (как минимум версию ядра и графической системы XFree86) каждого конкретного дистрибутива. Обычно эту информацию легко найти на сайте разработчика: например, для Red Hat этоhardware.redhat.com/hcl.
   Что касается минимальных системных требований, то малыми ресурсами могут обойтись лишь дистрибутивы, предназначенные к установке на компьютеры, обслуживающие сеть (шлюзы, интернет-серверы), которые в графическом режиме работать не должны. Для дистрибутивов же, ориентированных на домашнее или офисное применение, официальныеданные (как и в случае с Windows) занижаются беззастенчиво. Да, на машине с Pentium 133 и 32 MB RAM можно запустить Linux, но не работать. Pentium 200 MMX и 64 MB больше похожи на правду, но если вы планируете использовать оконную среду KDE 3, то и 128 MB памяти не окажутся лишними. В противном случае применяйте менее ресурсоемкую среду GNOME. Дополнительно нужно учитывать потребности прикладных программ, которые сами по себе могут быть весьма немаленькими.
   Одно из правил, которое следует всегда помнить: ОС Linux гораздо более требовательна к объему оперативной памяти, чем к частоте процессора: Pentium III 600 МГц/32 Мб будет работать гораздо медленнее, чем Celeron 400 МГц/64 Мб.
   Следует позаботиться и о видеосистеме — она должна обеспечивать (как минимум) комфортную работу с разрешением 1024x768.Дело в том, многие Linux-приложения проектировались исключительно для данного режима, поэтому при использовании 800x600могут возникнуть затруднения (часть окна просто не будет видна).
   Потребности в дисковом пространстве вполне стандартны по нынешним временам. Минимальная конфигурация требует 300–500 Мбайт, однако новичкам рекомендуется сразу устанавливать определенный набор прикладных программ, для которого требуется около 1,5 Гбайт. К тому же нужно оставить место для документов и рабочих файлов, так что в качестве отправной точки вполне подойдут два гигабайта.
   Я перечислю несколько дистрибутивов, которые купить можно, но сначала скажу о тех, которые покупать категорически не советую. Не нужно покупать экзотические дистрибутивы вроде LinuxXP и Lindows (он же Linspire). Правда, последний дистрибутив — редкость в интернет-магазине, но если вы его все-таки найдете, то не вздумайте покупать. Не верите мне? Тогда купите его. Вы поймете, что даром потратили свои деньги и время.
   В некоторых интернет-магазинах дистрибутивы Linux ставятся в один ряд с дистрибутивами FreeBSD. Так вот, FreeBSD покупать не стоит — во всяком случае, если вы не хотите купить еще одну книгу, но только по FreeBSD. Да, FreeBSD является дальним родственником Linux, но начинающему Linux-пользователю лучше с FreeBSD не связываться.
   Вы смело можете покупать Linux Mandriva (в прошлом — Linux Mandrake) и Fedora Core 4 (в прошлом — Linux Red Hat), а также дистрибутивы, так или иначе основанные на них — это ALT Linux 2.4, ASP Linux 10. Также смело можете купить не очень новую, но проверенную версию Linux Mandrake 10 — очень хороший дистрибутив.
   Вы можете купить дистрибутив Knoppix, но не как основной дистрибутив, а как вспомогательный, который вы сможете использовать как средство восстановления системы, когда в очередной раз вы переустановите Windows или же после неудачного эксперимента с загрузчиком Linux перестанет загружаться. Особенность Knoppix в том, что он может загружаться и нормально работать с компакт-диска.
   Дистрибутивы Debian и Slackware Linux — очень хорошие, стабильные и проверенные временем, но вам их лучше не покупать, поскольку они основаны на BSD-системе инициализации, которая ближе к миру BSD и в этой книге подробно не рассматривается. Конечно, если вы можете себе позволить еще одну книгу — по Slackware — то можете его купить. Но все-таки Slackware несколько сложнее в освоении, поэтому я рекомендую попробовать этот дистрибутив после того, как вы научитесь работать с Mandrake или Fedora Core. То же самое относится и к SuSe — немецкому дистрибутиву со своими, немецкими, особенностями. Лично мне больше нравятся французский дистрибутив Mandrake.
   Дистрибутив Gentoo, о котором много говорили определенное время назад, хорош тем, что позволяет настроить систему «под себя» в прямом смысле этого слова. Все устанавливаемые программы компилируются на вашем компьютере, а не устанавливаются из RPM-пакетов, содержащих уже откомпилированные начужоймашине двоичные файлы. Это главное достоинство этого дистрибутива, но оно же является и его главным недостатком — Gentoo начинающим пользователям противопоказан.
   Покупать остальные дистрибутивы нужно только в том случае, когда вы точно знаете, что это за дистрибутив и зачем он вам нужен.
   Теперь давайте рассмотрим дистрибутивы Linux Mandrake, Fedora Core 3 и Slackware Linux поближе. Первые два рассматриваются, чтобы у вас была возможность сравнить, a Slackware — чтобы вы поняли, почему его вам не нужно покупать (во всяком случае — пока).
   Смотреть на дистрибутивы я буду глазами начинающего пользователя, поэтому не удивляйтесь, что я не буду приводить рекомендации по исправлению той или иной ошибки — начинающий пользователь не знает, как ее исправить. Во время установки и работы с системой буду проводить небольшие тесты: а именно, сколько времени занимает процесс установки, сколько — загрузка системы, копирование файла и т.д. Время буду измерять не какой-нибудь программой, а обычным секундомером, встроенным в мобильник —это же домашние условия. Все дистрибутивы тестировались на следующей рабочей лошадке: Duron 1,6 GHz/256MB/HDD 40 GB 7200 rpm Maxtor/128 MB GeForceFX.
   Итак, начнем наш обзор. И начнем его с классики, то есть с дистрибутива Fedora Core.Fedora Core 3Установка
   Дистрибутив Fedora Core 3 поставляется на четырех компакт-дисках, но программа установки, если не отмечать какие-нибудь дополнительные пакеты, а оставить все как есть, требует только первые три компакт-диска.
   Как обычно, загружаюсь с компакт диска, нажимаю Enter для начала установки и одновременно (практически одновременно, сотые учитывать не буду) запускаю секундомер.
   Программа установки спросила меня, хочу ли я протестировать установочные диски. Как начинающий и ничего не понимающий в установке Linux пользователь, я согласился. Да мне и не хотелось «убивать» нормально работающий и уже установленный Linux Mandrake в случае, если что-то с компакта не скопируется, ведь FC3 должен быть установлен на его место.
   Во время установки я не отхожу от компьютера, чтобы оперативно отвечать на запросы программы-инсталлятора. Проверка первого диска не заняла много времени, а от проверки остальных дисков я отказался, нажав кнопку Continue.
   Программа установки очень удобна и проста — даже у начинающего пользователя не будет с ней проблем. Выбираю Выборочную установку и ручное разбиение дисков. Даже если вы — начинающий пользователь, я настоятельно рекомендую сделать то же. Ведь если выбрать другой тип установки, ваш винчестер будет переразбит, что приведет к потере всех ваших данных и установленной Windows вместе с ними. Здесь у меня будет небольшая погрешность в измерениях — ведь у меня уже есть созданные Linux-разделы, я только изменил тип файловой системы с ext2 на ext3 и выбрал форматирование этих разделов. Если у вас никогда еще не был установлен Linux, вам понадобится дополнительное время на создание разделов и изменения границ уже имеющихся разделов.
   Параметры загрузки — по умолчанию, чтобы не тратить дополнительное время на их установку.
   Следующий шаг — выбор программного обеспечения. Ведь я — начинающий пользователь, поэтому не знаю, что и для чего используется. Просто оставляю все как есть. Как пользователь понимающий, нужно заметить, что FC3 по умолчанию использует среду GNOME, a KDE вообще даже не предлагается устанавливать.
   Появляется окно «Запуск процесса установки…» и я перезапускаю секундомер. До этого весь подготовительный этап занял 7 минут и 31 секунду (7:31). [Картинка: img_7.jpeg] 
   Рис. 7.Установка Fedora Core 3
   Началось копирование пакетов на мой жесткий диск. Таймер программы-инсталлятора при копировании бессовестно врал: показывал 15 минут до вставки второго диска, а после этого момента стал показывать 10 минут, хотя прошло больше чем 5 минут. Четвертый диск в моем случае (все пакеты — по умолчанию) не понадобился. Установка (до появления окна перезагрузки компьютера) заняла 15 минут и 38 секунд (15:38).
   После первой перезагрузки система попросила указать некоторые параметры (дату/время, параметры дисплея), добавить новых пользователей, настроить звуковую плату ит.д. Сразу скажу, моя встроенная звуковая плата отказалась работать. Плата была опознана, но звука при воспроизведении семпла я так и не услышал. Пока оставил все как есть.Вторая перезагрузка
   Сразу перезагружаю систему. Запускаю секундомер (с момента начала загрузки ядра). Запуск системы (до окна ввода имени пользователя и пароля) занял на моей машинке всего 1 минуты и 8 секунд. Запуск GNOME занял еще 7 секунд.
   Начинаю работать с системой. Обновленный GNOME (версия 2.8.0) мне очень понравился. Первым делом я попытался выяснить, что же все-таки случилось с моей звуковой платой. Поскольку я начинающий пользователь, на ум мне не пришло ничего другого, кроме проверки уровня громкости. Ааа! Так все же устройства выключены, вот поэтому я и не слышал звук! Включаю, устанавливаю максимальную громкость. Запускаю проигрыватель компакт-дисков и вставляю Extra CD. GNOME предложил мне или открыть диск (чтобы просмотреть дорожку данных) или же воспроизвести (аудио-дорожки). Мелочь, а приятно. Выбираю воспроизведение. Все равно звука нет. В общем, звуковую карточку я пока оставил в покое. Пока посмотрю, что же нового в системе.
   Во время исследования файловой системы, я обнаружил, что файловые системы Windows (а у меня 4 Windows-раздела), не подмонтированы. Подмонтировать вручную особого труда не составляет, но что, если человек впервые видит Linux, и еле справился с установкой ОС, он ведь не знает, что есть команда mount! Но это уже другой вопрос — как говорится, RTFM перед установкой.
   Посмотрим, сколько места осталось после установки системы. Это можно выяснить программой df. Я устанавливал систему на раздел /dev/hda5, а раздел /dev/hda6 использовал для каталога /home. Сама система (/dev/hda5) заняла 2446188 блоков по 1 Кб, то есть2 388Мб. На разделе /dev/hda6 место практически не использовалось, поскольку при установке я не создавал пользователей.Программное обеспечение
   По умолчанию устанавливается не все программное обеспечение, а только самое необходимое. Очень понравился удобный просмотрщик изображений Photo Tool (рис. 8). [Картинка: img_8.jpeg] 
   Рис. 8. Photo Tool
   Также понравился обновленный GIMP 2.0.5, хотя с ним делал только скриншоты, его интерфейс стал более красивым и удобным (рис. 9). [Картинка: img_9.jpeg] 
   Рис. 9.Панель инструментов The GIMP2.0.5
   Хочу просмотреть видео. Пусть и без звука. Запускаю Helix Player — именно этот проигрыватель используется в FC3 для просмотра видео. Открываю файл, который без проблем воспроизводился в MDK, и вижу картину "The player does not have the capabilities to play back this content". Больше комментариев нет.
   Далее все как обычно — Open Office, Project Planner. Диаграммы DIA, утилиты настройки системы. Стоп! Кажется, в группе Интернет есть что-то новенькое — Firefox Web Browser. Запускаю. Как следует из названия, данный браузер основан на Mozilla. Только почему-то на английском.
   Исследовав опции, я так и не нашел выбора языка интерфейса, скорее всего, для его русификации нужно доустановить какой-то пакет.Тесты
   Переходим к самому интересному — тестам. Тесты будут следующими: тест чтения блока данных с помощью hdparm, тест на время копирования большого файла с раздела FAT32 в раздел ext3 и копирование этого же файла из одного раздела ext3 в другой раздел ext3. Хотел запустить привычный мне Midnight Commander, но его я не нашел и попытался установить с помощью утилиты «Управление пакетами». Данная утилита мне не понравилась. Она отлично подходит для начинающего пользователя, который и сам не знает, что он хочет установить. Мне же лучше было ввести имя пакета и установить его. К сожалению, в этой программе данной возможности не было. [Картинка: img_10.jpeg] 
   Рис. 10.Управление пакетами
   Тратить время на установку МС я не стал, а решил воспользоваться Браузером файлов. Может это и правильнее, ведь начинающий пользователь будет использовать именно его, а не какой-то МС, который даже не устанавливается по умолчанию. [Картинка: img_11.jpeg] 
   Рис. 11.Браузер файлов
   У нас есть уже все необходимые программы для проведения тестов. Начнем по порядку — с hdparm. Запускаю Терминал (находится в меню Приложения->Система). Результат чтения блока размером в 174 Мб за 3,02 сек довольно неплохой — это около 57,68 Мб/с.
   Теперь буду копировать файл размером ровно 700 Мб. Это фильм, который мне так и не удалось просмотреть. Получил такие результаты:
   ? Копирование с раздела FAT32 (/dev/hda10) на раздел ext3 (/dev/hda6): 2 мин 32 сек.
   ? Копирование с раздела ext3 (/dev/hda6) на раздел ext3 (/dev/hda5): 1 мин 04 сек.
   Как видите, с «родными» разделами FC3 работает в два раза быстрее. Файловая система ext3 использовалась только потому, что при нормальной установке она предлагается по умолчанию — ее и выберет начинающий пользователь. Он же и не подозревает о наличии других файловых систем.
   Все, обзор FC3 на этом заканчивается, и я решил выключить компьютер. При выключении вижу картину из серии «Не ждали»:
   Power down
   acpi_power_off called
   И все. Так машинка простояла минут пять, пока я вручную не выключил питание. Лично я вспомнил времена Windows 95: «А теперь питание компьютера можно отключить… вручную».Диагноз
   Лично я так и не понял, для кого этот разрабатывался этот дистрибутив: для начинающих или для продвинутых пользователей. Если для начинающих, о чем свидетельствуетдружественный интерфейс GNOME, то почему так много недоработок, с которыми начинающий справиться не в состоянии: неработающая звуковая плата (у меня довольно распространенная модель, поэтому такая неисправность будет наблюдаться не только у меня), ошибки при воспроизведении видео (очень актуальная задача для домашнего компьютера), не подключены файловые системы, а вдобавок ошибка при выключении питания? И это при том, что я поработал с системой какой-то час. Поработай я больше, даже не могу предположить, сколько недоработок я бы нашел в ней. Если же дистрибутив разрабатывался для продвинутых пользователей, почему нет привычных им программ (того же МС)? В любом случае я бы не рекомендовал этот дистрибутив начинающим пользователям. Сначала нужно поучиться на более легком дистрибутиве, у которого с самого начала все работает, а затем переходить на Fedora Core 3, если, конечно, захочется.
   Fedora Core 4,к сожалению, попробовать не получилось, привожу только версии программного обеспечения, входящего в этот дистрибутив.ПреимуществаНедостаткиДружественный интерфейс GNOME 2.8.0Проблемы с определением звуковой картыХороший выбор программного обеспеченияНе хватает видео-кодековУдобная программа установкиПроблемы с выключением питанияНовые версии GNOME и KDEПо умолчанию не устанавливаются некоторые привычные программыПо умолчанию не подмонтируются файловые системы WindowsТребует самостоятельной донастройки после установкиПрограммное обеспечениеFedora Core 3Fedora Core 4 (**)Ядро версия 2.6.9Ядро версия 2.6.11GNOME 2.8.0GNOME 2 8 3KDE 3.3.0KDE 3.4.0Open Office 1.1.2Open Office 1.9.104GIMP 2.0.5GIMP 2.2.7Загрузчик GRUBЗагрузчик GRUBSlackware
   Вторым дистрибутивом я решил выбрать Slackware. Просто хотелось на него посмотреть: ведь до этого я видел его в работе только несколько раз. А тут еще и последняя на данный момент версия — 10.1. Дистрибутив поставляется на двух дисках.Установка
   Как обычно, загружаюсь с первого компакт-диска. Вижу экран приветствия:
   Welcome to Slackware version 10.1 (Linux kernel 2.4.29)
   Что? Неужели последний дистрибутив от Slackware основан на старом ядре? Возможно, разработчики посчитали, что новое им не нужно.
   Так и есть: в состав Slackware и Debian включаются только старые добрые версии программного обеспечения, в том числе и ядра. Так разработчики пытаются создать стабильный дистрибутив, чтобы в нем не было различного рода недоработок.
   Знакомая загрузка ядра предыдущей версии. Программа установки предложила выбрать раскладку клавиатуры, отличную от US:
   Enter 1 to select a keyboard map
   Неужели установка системы будет в текстовом режиме? Да еще и без меню. Ага, нет, меню все-таки появилось, но текстовое. Меню выбора раскладки клавиатуры содержит список файлов (!) раскладок безо всякого описания. Догадайся, мол, сам. Выбираю qwerty/ru.map и нажимаю Enter. Честно говоря, текстовая программа установки выглядит как-то архаично. Такое впечатление, что устанавливается одна из первых версий Red Hat. Уже в 6.0 версии Red Hat программа установки была намного удобнее, хотя она тоже работала в текстовом режиме. Затем система предложила ввести пароль пользователя root. На данный момент пароля нет, поэтому можно просто нажать Enter, что я и сделал. Система сообщила, что для изменения таблицы разделов можно ввести команду fdisk. Мне повезло — Linux-разделы у меня уже есть, а начинающему пользователю лучше вообще отложить эту затею и попросить кого-нибудь более знающего переразбить жесткий диск за него. Только на использование текстовой версии fdisk может уйти минут пять — это при условии, если знаешь, что делаешь. К тому же fdisk не умеет изменять размеры разделов без уничтожения всей информации. Поэтому лучше использовать для этой цели какую-нибудь другую программу, например, тот же Partition Magic для Windows. Да, есть в Slackware более удобная программа — cfdisk, но в программе установке о ней ни слова…
   Для начала установки нужно ввести команду setup. Ввожу. Появляется меню программы установки. KEYMAP я уже выбрал, поэтому выбираю второй пункт ADDSWAP. Он позволяет установить раздел подкачки для вашей системы. У меня уже создан, поэтому программа запросила разрешения только активизировать этот раздел. После этого появилось текстовое окошко FORMAT, в котором нужно выбрать, какие Linux-разделы нужно форматировать, а также файловую систему. По умолчанию предлагается Reiser FS, но для равенства условий я решил выбрать ext3, чтобы результаты файлового тестирования были более объективными. Программа установки работает только на английском языке, поэтому если не знаете его. лучше вам попытаться установить другой дистрибутив.
   Затем программа спросила, хочу ли я добавить найденные Windows-разделы в /etc/fstab. Соглашаюсь и добавляю 2 из четырех разделов — для экономии времени. После этого нужно выбрать источник установки, выбираю Slackware CD or DVD, а также опцию auto для автоматического определения диска.
   Какие пакеты устанавливать? Выбираю full, то есть установку всех пакетов, чтобы не терять время на их выбор. До этого весь подготовительный процесс занял 6 минут и 6 секунд. У вас, скорее всего, этот показатель будет другим. А если у вас еще нет Linux-разделов, то можно смело умножить это время на 2.
   Время копирования пакетов с двух компактов заняло 13 минут и 10 секунд. После копирования пакетов программа установки настраивает шрифты, документацию и выполняет другие действия. На все про все ушло 53 секунды.
   Вот мы и добрались до самого интересного. Программа установки не знает, откуда брать ядро. Она предлагает несколько вариантов: bootdisk, Slackware CD и др. Причем первый — по умолчанию. Я его и выбрал, просто механически так получилось. Программа попросила вставить загрузочную дискету в дисковод /dev/fd0. У меня не только нет этой дискеты, нои самого дисковода. Отказаться — никак. Пришлось, не долго думая, нажать Reset и повторить весь процесс заново. Правильный вариант — Slackware CD. Затем — список ядер. Какое устанавливать? Я выбрал ядро, которое использовалось при установке:
   /cdrom/kernel/bare.i/bzImage
   Следующий этап — просто анекдотический. Программа хочет создать загрузочный диск, который она запрашивала на предыдущем этапе. Во как. Я отказался от этой возможности. После этого я также отказался от использования НОТPLUG-устройств. Для экономии времени.
   Настройку загрузчика LILO я производил вручную. Не полагаясь на интеллектуальные возможности программы, я выбрал expert и ввел все параметры вручную. LILO установил в MBR. Затем добавил две записи: Linux (/dev/hda5) и Win (/dev/hda1). Обычно эти параметры указываются автоматически — но это в нормальных программах установки… Для инсталляции LILO выбрал команду меню Install LILO.
   После этого нужно указать различные параметры системы — тип мыши, параметры сети (я их не устанавливал), выбор запускаемых сервисов (оставил как есть). Потом программа спросила, хочу ли я добавить свои собственные консольные шрифты. А откуда ж они у меня? Ясно, что я отказался от этого. Затем — параметры времени (UTC или не UTC, выбор региона, я выбрал Europe/Kiev).
   После установки времени нужно выбрать оконный менеджер по умолчанию. Программа предложила KDE, я согласился.
   Последний этап — ввод пароля root. Все. Перезагружаться сами не захотели — мол, уже не маленькие, знаете, как Ctrl+Alt+Del нажимать. Нажимаю заветную комбинацию, и система перезагружается. С момента выбора ядра до перезагрузки прошло 4 минуты и 51 секунда.
   Загружаюсь. Система встретила меня голой консолью. Ввожу имя пользователя root и свой пароль. Все. Для запуска X Window (ну и KDE) нужно ввести startx. Некоторые пользователи Linux, даже которые уже использовали эту ОС, и не подозревают о существовании такой команды.Вторая перезагрузка
   Я перезагружаю систему, чтобы вычислить время второй загрузки. Оно составило 22 секунды до появления приглашения ввести имя пользователя и пароль и еще 22 секунды на запуск X Window и KDE. Итого 44 секунды. После установки на разделе размером 3 Гб осталось 473 Мб свободного места.Программное обеспечение
   В этом дистрибутиве используется новая версия KDE — 3.3.3 и еще более новая, чем в FC3, версия GIMP — 2.2.3.
   KDEрусифицировать никак не удалось. Я установил все пакеты, а из доступных языков был только английский. И кому нужен такой дистрибутив?
   Существенным недостатком, на мой взгляд, является отсутствие пакета OpenOffice. Вместо него установлен K Office 1.3.4. [Картинка: img_12.jpeg] 
   Рис. 12.Рабочий стол KDE 3.3 (Slackware)Тесты
   А вот тут началось самое интересное. Результат hdparm такой же, как и у FC3. 174 Мб скопировалось за 3,01 секунды. При копировании того же самого 700-Мбайтного фильма я получил следующие результаты:
   ? Копирование с FAT32-раздела на ext3-раздел: 1 мин 12 сек (!)
   ? Копирование с ext3-раздела на ext3-раздел: 0 мин 31 сек
   Вот вам и ядро 2.4. Разница с FC почти в два раза: Slackware в два раза быстрее работает с файлами, чем Fedora Core. Файловая система одна и та же — ext3. Уже и не знаешь, куда отнестиверсию ядра 2.4 — к преимуществам или недостаткам. Никуда не буду относить. Будем считать это особенностью данного дистрибутива.Диагноз
   Неудобная текстовая англоязычная программа установки сразу отпугнет начинающих пользователей. Отсутствие Open Office и поддержки русского языка тоже не в сторону выбора дистрибутива. Зато это компенсируется быстрой работой файловой системы и более быстрым запуском системы: 44 секунды против 1 минуты и 15 секунд у FC3. Этот дистрибутив можно порекомендовать квалифицированным пользователям, знающим толк в Linux — уж они-то смогут довести его «до ума». И вообще, учитывая особенности этого дистрибутива, он больше подходит для установки на сервере, чем на рабочей станции.ПреимуществаНедостаткиДружественный интерфейс KDE 3.3Неудобная, текстовая и англоязычная программа установкиВысокая производительность файловой системыНет поддержки русского языка. Ее обеспечить можно, но начинающему пользователю придется потратить на это уйму времениБыстрая загрузка системыОтсутствует пакет Open OfficeПрограммное обеспечениеЯдро версия 2.4.29GNOME 2.6.2KDE 3.3Open Office— отсутствуетGIMP 2.2.3Загрузчик LILOLinux Mandrake 10.1
   Этот дистрибутив я устанавливал последним специально: до этого на моем домашнем компьютере был установлен именно он. Как обычно, начнем с установки дистрибутива.Установка
   Как и Fedora Core 3, Mandrake поставляется на четырех компакт-дисках. Все четыре диска нужны при установке — даже если не отмечать дополнительные пакеты.
   Программа установки понятна и новичку, с ней практически не бывает проблем — это я уж знаю точно, потому что данный дистрибутив я устанавливал не один раз, причем на разные компьютеры.
   Весь подготовительный процесс в моем случае (напомню, что я не создавал разделы — они уже были созданы) занял всего 2 минуты и 1 секунду. На копирование пакетов, выбранных по умолчанию, понадобилось всего 7 минут и 2 секунды. После копирования пакетов на указание дополнительных параметров (я оставил все по умолчанию, только добавил одного пользователя) понадобилось 1 минута и 12 секунд. Итого на установку системы понадобилось 10 минут и 15 секунд (!)
   После перезагрузки приятно обнаружить, что твоя звуковая плата работает, консоль полностью русифицирована (а не как в случае с FC3), подмонтированы все Windows-разделы (причем подмонтированы правильно — с русскими буквами проблем нет), да и выключается компьютер без всяких глюков.Вторая перезагрузка
   Вторая загрузка (с запуском X Window и автоматическим входом пользователя) заняла 42 секунды. После установки осталось свободным 2,1 Гб дискового пространства.Программное обеспечение
   На четырех компакт-дисках Linux Mandrake вы найдете все необходимое программное обеспечение — от офисных приложений до простых игрушек. Для меня наиболее важны офисный пакет OpenOffice 1.1.0 и графический редактор GIMP 1.2.5. Версия GIMP не очень новая, но это поправимо — всегда можно загрузить новейшую. [Картинка: img_13.jpeg] 
   Рис. 13.Рабочий стол [Картинка: img_14.jpeg] 
   Рис. 14. Windows-разделы сразу правильно подмонтированы [Картинка: img_15.jpeg] 
   Рис. 15.Воспроизведение фильма
   В качестве оконной среды по умолчанию используется KDE версии 3.2 — довольно удачная и быстрая версия.
   С воспроизведением видеофайлов нет никаких проблем — все фильмы, имеющиеся у меня на Windows-разделах, были воспроизведены проигрывателем Totem — даже те, для которых яв Windows выкачивал из Интернета дополнительные кодеки.Тесты
   Дополнительно описывать тесты я не буду, а приведу только уже готовые результаты:
   ? Hdparm: 174 Мб прочитано за 3,02 секунды, скорость чтения 57,55 Мб/с;
   ? Копирование 700-Мбайтного файла с FAT32-раздела на ext3-раздел: 01:26;
   ? Копирование 700-Мбайтного файла с ext3-раздела на ext3-раздел: 0:36.Диагноз
   Linux Mandrake— отличный дистрибутив для начинающих пользователей. После установки системы пользователь получает «готовую к употреблению» рабочую среду. Все, что ему нужно настроить (и то, только если он это не сделал при установке системы) — это настроить сеть и/или подключение к Интернету. Никаких особых проблем ни при установке, ни при работе с дистрибутивом не возникло.ПреимуществаНедостаткиПростая и быстрая установкаОсобых недостатков нет, если не считать немного устаревших версий GNOME и GIMPХороший выбор программного обеспеченияПосле установки система полностью готова к работе и не требует донастройкиНет проблем ни со звуком, ни с видео-кодекамиПрограммное обеспечениеLinux Mandrake 10Linux Mandriva 2005 (*)Ядро версия 2.6.3Ядро версий 2.6.11.6GNOME 2.4.1GNOME 2.9.3KDE 3.2KDE 3.3.2с поддержкой функций 3 4 0Open Office 1.1.0Open Office 1.1.4GIMP 1.2.5GIMP 2.2.5Загрузчик GRUBЗагрузчик GRUBПримечание
   Linux Mandriva Limited Edition 2005— это первый выпуск популярного дистрибутива после слияния компаний MandrakeSoft и Conectiva. В этом дистрибутиве есть очень много интересного — от полной поддержки контроллеров Adaptec до поддержки игровых консолей Xbox.
   РазноеASP Linux
   Если вы не достанете Mandrake (что маловероятно), установите ASP Linux (www.asplinux.ru)— вам понравится. Своей отлаженностью и стабильностью он произвел на меня очень приятное впечатление.
   Дистрибутив отличается хорошей совместимостью с видеоакселераторами NVidia, ATI, а также чипсетом SiS630, который часто используется в ноутбуках.
   ASP Linuxтакже выделяется улучшенной поддержкой украинского языка и возможностью легкой смены кодировки (koi8-r, koi8-u, cp1251, iso8859-5). Естественно, в состав дистрибутива входят OpenOffice и другие традиционные Linux-приложения. Неожиданностью для меня стало наличие антивируса (eSafe от компании Aladdin), а включение в дистрибутив бухгалтерского программного обеспечения (от компании Hansa) — явление просто уникальное. Имеется также масса вспомогательных средств, например, система автоматического обновления, автоопределение приводов CD-RW и DVD и т.п.
   Наиболее полный дистрибутив версии 7.3 «Восток» распространяется на десяти (!) компакт-дисках, среди которых три установочных, два с исходными текстами, по одному с документацией, играми и пользовательскими приложениями. На отдельном CD-ROM поставляется полная версия Acronis OS Selector 8.0, еще один диск содержит демонстрационные версии серверных приложений.
   В коробочную поставку ASP Linux входят печатные руководства «Быстрый старт», «Руководство по инсталляции», «Руководство пользователя», «Руководство администратора», которые фактически освобождают пользователя от необходимости приобретения дополнительной литературы по Linux.
   К тому же на Documentation CD, кроме традиционных FAQ и HOWTO от группы Linux Documentation Project, содержатся и их переводы, выполненные командой ASP Linux и сторонними переводчиками. Просмотр электронной документации обеспечивается через удобный гипертекстовый интерфейс.
   На момент написания книги уже вышла десятая версия этого отличного дистрибутива.ALT Linux
   Использовать для обучения дистрибутив ALT Junior 2 я не рекомендую — уж слишком все там просто. Так вы уподобитесь иным пользователям Windows, которые привычно переустанавливают ОС при малейших затруднениях. Зато этот дистрибутив прекрасно подойдет, если вы хотите заменить Windows в офисе или дома — поставьте и не мучайтесь. В нем имеется полный комплект «стандартных» офисных приложений, приложения для работы в Интернете, проигрыватели MP3 и MP4, поддерживаются цифровые камеры, USB-принтеры и много чего еще. Сразу после установки практически все это будет уже настроено, останется лишь изменить имя компьютера и параметры PPP-соединения. Интересно, что при этом ALT Junior 2 очень компактен, все необходимое ПО уместилось фактически на одном компакт-диске, на втором размещены исходные тексты и дополнительные средства разработки.
   Что еще хорошо в этом дистрибутиве, а точнее, в политике компании ALT Linux (www.altlinux.ru),так это сопровождение — обновления появляются регулярно и оперативно. Скажем, версия 2.0 отличалась некоторой нестабильностью работы, однако вскоре вышел доработанный Junior 2.1.
   Дистрибутив ALT Master предназначен для пользователей, уже знакомых с Linux. Он также создает впечатление более стабильного и надежного, чем ALT Junior. К тому же в коробочной версии вы найдете целых шесть компакт-дисков с различным программным обеспечением для Linux, в том числе — популярный эмулятор VMWare, который позволяет запускать одну ОС внутри другой.
   Говоря о локализации, зачастую подразумевают только перевод интерфейса и возможность ввода символов национального алфавита и напрочь забывают о документации. Компания ALT Linux демонстрирует более цельный подход и в этом вопросе: в комплект стандартной поставки ALT Junior 2 входит печатное руководство по установке операционной системы. Хотя, на мой взгляд, в нем не хватает иллюстраций, с его помощью новичку будет гораздо проще инсталлировать ОС. Кроме того, в нем содержится краткая информация по установке дополнительных программ и обновлений.
   В состав коробочной версии дистрибутива ALT Master входят четыре (!) прекрасных печатных руководства: по инсталляции ОС, администратора и пользователя, а также отдельное по OpenOffice. Можно с уверенностью сказать, что на первое время этой литературы более чем достаточно. А если учитывать, что руководства составлены разработчиками ALT Linux и все описанные в них примеры ориентированы на «родной» дистрибутив, то им и вовсе цены нет.
   Говоря о политике компании ALT, невозможно не упомянуть Sisyphus — ежедневно обновляемый репозиторий пакетов программного обеспечения. Все дистрибутивы ALT Linux созданы на его основе. Для чего это нужно? Если у вас есть постоянный доступ к Интернету, вы можете настроить ваш дистрибутив на ежедневное обновление пакетов — тогда ваша система всегда будет поддерживаться в «актуальном состоянии» и вам не нужно будет периодически устанавливать новые версии — все будет происходить автоматически.
   Конечно, автоматическое обновление имеет свои преимущества и недостатки — вы же обновляете программное обеспечение, а не простую базу данных. Новое программное обеспечение может содержать новые функции, что является положительной стороной, но и «подводные камни»: никто не знает, сколько ошибок было внесено в программу при исправлении уже известных ошибок и добавлении новых функций. Лично я никому не доверяю обновлять свою систему (это даже недопустимо с точки зрения безопасности), поэтому предпочитаю покупать и устанавливать новые версии дистрибутивов. Впрочем, если в ваш дистрибутив какой-то пакет не включен, в репозитории Sisyphus вы, скорее всего, его найдете.
   Подробнее о Sisyphus вы сможете прочитать по адресуwww.altlinux.ru.SuSE Linux
   SuSE Linux— немецкий дистрибутив компании Novell. Это очень хороший, надежный дистрибутив с «немецким качеством». Чего стоит только тот факт, что разработчик этот дистрибутива — компания Novell — разработала одну из самых надежных сетевых операционных систем Novell Netware. Ранние версии SuSE грешили недружелюбием по отношению к русскому языку, но в последних версиях этот недостаток искоренен. Последние версии SuSE можно порекомендовать не только опытным (как это было с предыдущими версиями), но и начинающим пользователям Linux. Последняя на момент написания этих строк (9.2) версия SuSE содержит:
   ? ядро версии 2.6.8;
   ? KDE версии 3.3.0;
   ? Open Office 1.1.3 — популярный офисный пакет, аналог MS Office;
   ? KOffice 1.3.3 — еще один офисный пакет;
   ? The GIMP 2.0.4 — мощнейший графический редактор, аналог PhotoShop;
   ? много другого полезного программного обеспечения.
   Версия 9.2 поставляется на пяти компакт-дисках — как видите, дистрибутив не маленький (для сравнения: Mandrake 10 поставляется на четырех CD).
   Подробно об этом дистрибутиве вы сможете узнать по адресуwww.suse.com,а если заинтересуетесь, то можете купить его в любом интернет-магазине.Knoppix
   Эта разработка Клауса Кноппера (www.knopper.net/knoppix)— самый лёгкий и быстрый способ познакомиться с Linux. Дистрибутив поставляется на одном-единственном компакт-диске и может работать прямо с него, без установки на компьютер. Хотя при желании вы можете и установить его на жесткий диск, а дополнительные программные пакеты скачивать из архива наwww.debian.org.Да, этот дистрибутив основан на Debian, т.е. не родствен Red Hat.
   При таком детском размере Knoppix содержит недетское количество программного обеспечения, включая офисные пакеты, медиа-плейеры и средства работы в Интернете. Дело втом, что программы уложены на диск в сжатом виде и в процессе запуска распаковываются из архивов на лету.
   Самая свежая на момент написания этой книги версия дистрибутива — Knoppix 3.8.1 — продается в интернет-магазинеknoppix.ruза 99 рублей.Debian
   Debian— это целая линия развития Linux, альтернативная Red Hat и не слишком совместимая с ней. Среди лидирующих дистрибутивов Debian — единственная полностью некоммерческая система. Если разработкой Red Hat занимается Red Hat Software, а за Slackware стоит Walnut Creek, то дистрибутив Debian/GNU Linux создает и поддерживает группа энтузиастов — строго в духе движения за открытые исходники. Не зря его предпочитает Ричард Столлмен, лидер Фонда Свободного Программного Обеспечения.
   Debian— настоящая энциклопедия свободных программ: в его состав входит более 15490 пакетов заранее скомпилированного программного обеспечения, которые можно бесплатно скачать сwww.debian.org/distrib/packages.Там же предлагаются дополнительные пакеты, которые нельзя включать в основной дистрибутив, потому что их лицензии не соответствуют принятому в этой группе определению бесплатного программного обеспечения (с правом дальнейшего распространения, наличием исходных текстов, разрешением их модификации и использования в качестве основы новых разработок). Система управления пакетами у Debian собственная, похожая на Red Hat'овскую только внешне.
   Debianпользуется также репутацией самого надежного дистрибутива благодаря тому, что его разработчики имеют опубликованные точные критерии качества программного обеспечения и отлаживают его исключительно тщательно. Вместе с тем поддерживается так называемая «нестабильная» ветвь — экспериментальное направление, на котором разрабатываются новейшие идеи.
   Годы работы многих сотен разработчиков сделали Debian самым понятным, логичным в настройке и администрировании дистрибутивом. Но для быстрого старта он не подходит: разработчики не приняли во внимание интересы желающих щелкать мышью и не лезть в основы системы.
   Глава 1
   Установка операционной системы
   1.1.Подготовка жесткого диска
   Сейчас на вашем компьютере установлена, скорее всего, одна из ОС семейства Windows со своей файловой системой. ОС Linux использует другой тип файловой системы, поэтому для ее установки вы должны освободить место на диске и отформатировать его (т.е. создать на нем новую файловую систему). Если вы не намерены окончательно избавляться от Windows, то вам придется создать на диске несколько разделов, каждый для своей операционной системы.Примечание
   Существует несколько определений файловой системы. Для себя вы можете выбрать одно из нижеприведенных — они оба вполне корректны.
   Файловая система— часть операционной системы, обеспечивающая выполнение операций над файлами.
   Файловая система— способ организации и представления битов на жестком диске.
   Разделом называется участок жесткого диска, к которому можно обратиться как к отдельному диску, что достигается использованием таблицы разбиения жесткого диска (partition table).Эта таблица записана в самом начале диска и подразделяется на 4 секции, содержащие характеристики 4 возможных разделов: их расположение, тип и отметку об активности. Отметка об активности используется загрузчиками некоторых ОС, в частности, Windows может быть загружена только из «активного» раздела.
   Эти 4 раздела называются первичными (primary).Один из разделов может иметь тип «расширенный» (extended).Такой раздел содержит собственную таблицу разбиения на один или несколько разделов, называемых логическими (logical).Таким образом, пространство жесткого диска может быть структурировано удобным вам способом.
   Итак, на вашем диске достаточно места для установки Linux, но все это место находится в активно используемом разделе, содержащем ОС Windows и все данные. Вы можете:
   ? Полностью переразметить диск.
   При этом вы уничтожаете один большой раздел и создаете на его месте несколько маленьких. Все данные, конечно, будут потеряны, и Windows тоже придется переустановить. Ваши действия:
    1. Убедитесь, что у вас есть компакт-диск, с которого можно переустановить исходную ОС;
    2. Создайте резервную копию всех своих данных;
    3. Разбейте диск на разделы с помощью утилитыfdiskот Windows;
    4. Восстановите свои данные и возвращайтесь к установке Linux.
   ? Уменьшить имеющийся большой раздел с сохранением данных.
   Существует несколько программ, позволяющих это сделать. В предыдущие дистрибутивы Red Hat входила утилитаfips,умевшая работать с разделами FAT и FAT32, но не NTFS. Она все еще доступна по адресуhttp://www.igd.fhg.de/~aschaefe/fips,но в современные дистрибутивы обычно не включена. Вместо нее лучше воспользоваться программойPartitionMagicот Symantec Norton, понимающей все типы файловых систем. Ваши действия:
    1. Уплотните существующие данные (дефрагментируйте ваш диск), чтобы увеличить свободное место в «конце» раздела.
    2. Уменьшите размер раздела, создав на диске неразмеченное пространство.
    3. Создайте новые разделы. Можете отложить этот шаг до этапа установки Linux: инсталляторы современных дистрибутивов (в частности, Fedora Core и Mandrake) вызывают специальную программу для работы с разделами диска.
   1.1.1.Рекомендуемая схема разбиения диска
   ? Раздел подкачки или свопинга (swapping)— используется виртуальной памятью. Иными словами, данные, не умещающиеся в оперативной памяти, перемещаются на жесткий диск. Например, у вас в данный момент свободно всего 8 Мбайт оперативной памяти, а вы пытаетесь открыть документ размером в 16 Мбайт. В оперативную память при этом будут загружены первые несколько мегабайт, а все остальное будет находиться во внешней памяти. Когда вам потребуется перейти в конец документа, операционная система подкачает в память нужные данные, а неиспользуемые будут помещены во внешнюю память. Размер раздела подкачки должен быть не меньше 32 Мбайт. Обычно его размер равен удвоенному объему оперативной памяти.
   ? Раздел/boot— содержит ядро операционной системы и несколько файлов, используемых при загрузке. Необходимость этого раздела вызвана «барьером 1024 цилиндра», то есть тем, что BIOS большинства персональных компьютеров «не видит» цилиндров с номерами больше 1024. Рекомендуемый размер этого раздела — 100 Мбайт.
   ? Корневой раздел, содержащий файлы, необходимые для работы системы и прикладных программ;
   ? Раздел/homeдля пользовательских данных.
   1.1.2.Имена разделов в ОС Linux
   Linuxпредставляет наименования разделов как имена файлов, в виде/dev/xxyN,где:
   ? /dev— это каталог, в котором расположены все файлы, связанные с устройствами;
   ? xx— две буквы названия раздела, указывающие тип устройства, на котором размещается раздел. Как правило, это либоhd (если это IDE диск), либоsd (для SCSI дисков);
   ? y— буква, описывающая само устройство, на котором находится раздел. Например,/dev/hda (первый IDE жесткий диск) или/dev/sdb (второй SCSI диск);
   ? N— число, обозначающее непосредственно раздел. Первичные разделы нумеруются числами с 1 по 4. Нумерация логических разделов начинается с 5, даже если первичных разделов меньше четырех.
   Таким образом,/dev/hda2— это второй первичный раздел на первом диске IDE, a/dev/sdb5— это первый логический раздел на втором диске SCSI.
   1.1.3.Разделы и точки монтирования
   С логической точки зрения файловая система каждого раздела представляет собой отдельное дерево каталогов. Объединение их в общую иерархическую структуру с однимкорнем достигается путем ассоциирования раздела с одним из каталогов, содержащихся в корневом каталоге. Эта операция называется монтированием (mounting).Монтирование раздела дает доступ к нему через указанный каталог, называемый точкой монтирования (mounting point).
   Например, если раздел/dev/sdb5был смонтирован как/home/ivan/doc,то все файлы и каталоги, находящиеся в/home/ivan/doc,физически будут размещаться на/dev/sdb5.А файлы, находящиеся в/home/ivan/doc/Russian,— на/dev/sdb6,если назначить каталогRussianточкой монтирования для раздела/dev/sdb6.
   1.2.Загрузка программы установки
   1.2.1.С использованием загрузочного компакт-диска
   Самый удобный и уже самый распространенный способ. Первый диск любого дистрибутива — загрузочный. Вставьте его в дисковод, перезагрузите компьютер, войдите в BIOS Setup и сделайте CD-привод первым в последовательности загрузки.
   Некоторые дистрибутивы (например, Mandrake 10.0) предлагаются на DVD, с которыми нужно поступать точно так же (если, конечно, у вас есть соответствующий привод).
   1.2.2.С использованием загрузочной дискеты
   Способ настолько устаревший, что в современные дистрибутивы загрузочный образ для дискеты и не включен. Опишу его, опираясь на дистрибутив RedHat 7.1.
   1. Скопируйте каталогиdosutilsиimagesна жесткий диск (желательно на С:).
   2. Перезагрузите компьютер в режиме MS DOS.
   3. Введите командуrawrite (если вы — на свой страх и риск— предпочитаете работать в Windows, то пользуйтесь командойrawritewin):
   С:\&gt;с:\dosutils\rawrite
   На запрос программы
   Enter disk image source file name:
   введите:
   с:\images\boot.img— для обычной установки или
   с:\images\bootnet.img— для установки по сети.
   А затем на предложение программы ввести диск назначения введите имя дискеты:
   Enter destination drive:
   а:
   4. Вы получили загрузочную дискету. Вставьте ее в дисковод и перезагрузите компьютер.
   Внимательно прочитайте INSTALL.TXT в корневом каталоге CD, загляните также в каталогimagesи прочитайте файл README. Инструкции по установке обычно находятся там.
   1.2.3.С использованием жесткого диска
   Если вы скачали образы компакт-дисков дистрибутива, то можете прожечь их на CD и устанавливать так, как сказано в п. 1.2.1. Когда скорость вашего CD-привода слишком мала (например, 4x), имеет смысл разместить ISO-образы на жестком диске, а с CD только загружаться. Загрузочный образ находится в каталогеimagesна первом диске дистрибутива и называетсяboot.iso.
   Если какой-то вариант Linux у вас уже установлен, то вы можете извлечь этот файл из файла образа, смонтировав этот образ:
   $ mount -о loop -t iso9660&lt;файл_iso&gt;&lt;точка_монтирования&gt;
   Прожгите файлboot.isoна компакт-диск и загрузитесь с этого компакт-диска.
   Если ваш BIOS поддерживает загрузку с USB-устройств, то вы можете скопировать на USB-диск загрузочный образimages/diskboot.imgс первого диска дистрибутива. Из-под Linux это можно сделать так:
   $ dd if=diskboot.img of=/dev/sda1
   После чего загрузитесь с USB-диска и следуйте указаниям программы установки.
   Если вы загружаетесь с дистрибутивного CD, но устанавливать собираетесь с жесткого диска, то в ответ на приглашение загрузчика
   boot:
   введите тот вариант загрузки, который позволяет выбрать устройство (в дистрибутиве Fedora Core эта директива называется askmethod). Укажите инсталлятору раздел диска и каталог, в котором находятся образы дисков дистрибутива.
   1.2.4.Установка по сети
   Для этого варианта установки вам нужно иметь доступ к FTP-серверу, где хранится каталог с избранным вами дистрибутивом. Загрузитесь с того носителя, на который вы скопировали загрузочный образ, ответьте на вопросы инсталлятора и выберите в качестве устройства для установки FTP-сервер. [Картинка: img_16.jpeg] 
   Рис. 1.1.Установка RedHat по протоколу FTP
   1.3.Установка Fedora Core
   1.3.1.Описание дистрибутива
   Название проекта Fedora Core не имеет никакого отношения к знакомому нам с детских дет произведению К.И. Чуковского «Федорино горе». Fedora Core является наследницей линейки RedHat (бесплатной), a Fedora означает фетровая шляпа (против Красной Шапочки RedHat)
   Fedora Core Linux— это наследник культового дистрибутива Red Hat Linux, созданный сообществом добровольцев Fedora Project (http://www.redhat.com/fedora)при участии и спонсорской поддержке компании Red Hat. Дистрибутивы Fedora Core содержат только новейшие версии программного обеспечения. Лучшие решения, найденные командой разработчиков Fedora, Red Hat включает в программное обеспечение, поставляемое в ее коммерческих дистрибутивах Enterprise Linux.
   Несмотря на это, Fedora Core — не тестовая площадка для энтузиастов, а полноценный дистрибутив, пригодный для домашнего, офисного или серверного применения. Дистрибутив включает удобную программу для установки и полный набор приложений — офисные пакеты, браузеры и web-сервера, мультимедийные средства и инструменты разработчика ПО. Fedora Core Linux может легко соседствовать с MS Windows как на одном компьютере, так и в локальной сети, а офисный пакет OpenOffice позволяет без проблем открывать, редактировать и сохранять документы в форматах MS Word и MS Excel.Версии Fedora Core — 1, 2, 3 и 4. Системные требования
   На момент написания этой книги вышло четыре версии дистрибутива Fedora Core. Первая версия работала еще недостаточно стабильно. Во второй замечен довольно неприятный баг, мешающий сосуществованию Fedora Core 2 и Windows, особенно Windows XP, на одном компьютере: после установки FC2 на некоторые жесткие диски Windows перестает загружаться. Данные в разделах Windows при этом не портятся, но для того, чтобы Windows снова стала распознавать эти разделы, требуется вручную реконфигурировать жесткий диск. В третьей версии этот баг устранен, однако появилось множество других. Так что рекомендуется использовать вторую версию вместо третьей. В последней, четвертой версии FC ошибки предыдущих версий были исправлены. Так что что в качестве рекомендации могу посоветовать именно ее.
   Третью версию устанавливать не рекомендуется ввиду ее нестабильности и большого количества возникающих коллизий (типа неработающих драйверов и т.п.), разрешить которые может только опытный пользователь, но и ему зачем с этим всем возиться — тоже не совсем понятно. Лучше изначально выбрать стабильный дистрибутив.
   Команда разработчиков Fedora Project обещает выпускать новые версии дистрибутива 2-3 раза в год. Вы можете следить за новостями на страницеhttp://fedora.redhat.com.
   Системные требования всех версий обычны для современных дистрибутивов:
   ? процессор класса не ниже Pentium (Pentium 200 МГц для работы в текстовом режиме, Pentium II 400 МГц или лучше — для работы с графикой);
   ? память: не менее 64 Мб для текстового режима, не менее 192 Мб (рекомендуется 256 Мб) для графического;
   ? пространство на диске зависит от выбранного типа установки:
   ? 620 Мб — минимальная установка;
   ? 1.1 Гб — сервер;
   ? 2.3 Гб — настольный компьютер;
   ? 3.0 Гб — рабочая станция;
   ? 6.9 Гб — полная установка.
   Кроме того, сама программа установки требует еще от 90 Мб (минимальная установка) до 175 Мб (полная установка) дополнительного пространства на жестком диске, которое после завершения установки будет освобождено. И, конечно, нужно место для пользовательских данных и не менее 5% дискового пространства для работы самой системы.
   Вторая версия Fedora Core отличается от первой следующими новинками:
   ? Ядро версии 2.6 со всеми вытекающими отсюда последствиями (лучшая масштабируемость, производительность и поддержка новых устройств).
   ? Новая версия системы X Window X11R6.7.0.
   ? Новая версия оконной среды GNOME (2.6), которая работает значительно быстрее предыдущей.
   ? Новая версия оконной среды KDE (3.2.2), в которой исправлены некоторые проблемы, включая проблемы с переводом интерфейса.
   ? Xfce 4: легкое и быстрое окружение рабочего стола.
   ? Поддержка технологии Subversion 1.0, которая должна заменить технологию CVS.
   ? Реализация системы безопасности SELinux.
   В третьей версии добавлены или обновлены:
   ? Новая версия оконной среды GNOME 2.8.0.
   ? Новая версия оконной среды KDE 3.3.0 (к сожалению, пока только на английском).
   ? Клиент электронной почты Evolution 2.0.
   ? Дополнительная «целевая» политика безопасности SELinux, следящая не за всеми операциями, а только за определенными демонами.
   ? Динамическое управление каталогом устройств (программа udev), позволяющее создавать файлы устройств по мере подключения драйверов.
   В четвертой версии Fedora Core, появившейся 13 июня 2005 г. можно отметить следующие особенности:
   ? Ядро версии 2.6.11.
   ? Fedora Core 4 стала первым дистрибутивом, скомпилированным с помощью четвертого компилятора GNU С (GCC).
   ? Новая версия системы X Window X11R6.7.0.
   ? Новые версия оконных сред: GNOME 2.10 и KDE 3.4.0.
   ? Кластерная файловая система GFS 6.1.-0.pre22.
   ? Универсальный просмотрщик документов Evince 0.2.1.
   ? Существенно улучшенная и расширенная целевая политика безопасности SELinux (дополнительно стали покрываться еще 80 демонов).
   ? Eclipse 3.1М6. — полнофункциональная среда Java-разработок.
   ? Некоторые приложения оказались из дистрибутива изъяты. В четвертой версии FC вы не найдете exim, XFce 4, медиаплеера xmms и даже KOffice. Разработчики пошли, на мой взгляд, вполне правильным путем и стали помещать в дистрибутивы только приложения, лучшие в своей функциональной категории. Например, возможности XFce 4 с лихвой покрываются возможностями KDE и GNOME, так зачем же из дистрибутива делать свалку программ. При этом, если вам нужна какая-то программа, отсутствующая в дистрибутиве, вы всегда сможете ее бесплатно скачать.
   Детальную информацию о новинках и нововведениях в четвертой версии можно узнать по адресуwww.rhd.ru/docs/manuals/fedora/4/RELEASE-NOTES-ru.html.Специальная технология разграничения доступа SELinux
   SELinux (Security Enhanced Linux)— это технология, позволяющая лучше защитить ваш компьютер от взлома и непродуманных действий пользователей. Технология SELinux работает совместно с механизмом нрав доступа в Linux, позволяя администратору ввести дополнительные правила доступа к файлам.
   Работает это так: если права доступа запрещают доступ к файлу, запрос отклоняется сразу. Если же права доступа разрешают доступ к файлу, настает черед SELinux. Система SELinux проверяет текущие правила работы с данным файлом для запросившего его процесса, запустившего процесс пользователя и выполняемой им «роли» (например, сам администратор может запретить себе доступ к критически важным ресурсам, когда он не в административной роли. Тогда даже украденный пароль root не слишком поможет злоумышленнику). Если правила SELinux не разрешают доступ к этому файлу, операция отклоняется. Как видите, SELinux — это еще один барьер в системе безопасности вашего сервера (или просто домашнего компьютера).
   Кроме ограничения доступа к файлам, с помощью SELinux можно ограничивать действия отдельных пользователей, групп пользователей, процессов. Подробно о SELinux на русском языке вы сможете прочитать по адресуhttp://www.opennet.ru/base/sec/intro_selinux.txt.html.
   1.3.2.Особенности установки различных версий Fedora CoreFedora Core 2:подготовка к совместной жизни с Windows
   Если вы собираетесь держать на одном компьютере ОС Windows и Fedora Core 2, то не торопитесь устанавливать FC 2. Дело в том, что программа-инсталлятор этой версии дистрибутивапо-своему определяет параметры физической разметки жесткого диска. После того, как эти параметры будут занесены в таблицу разделов, Windows перестанет распознавать диск. Чтобы обойти эту ошибку, нужно помешать инсталлятору автоматически определять параметры разметки диска, указав их вручную.
   Для определения геометрии диска (цилиндры, головки и секторы, CHS) служит утилитаfdisk,входящая в любой дистрибутив Linux. Если никакого Linux у вас еще не установлено, то загрузитесь с первого компакт-диска устанавливаемого дистрибутива и в ответ на приглашение загрузчика введите параметр ядра rescue:
   boot: linux rescue
   Будет загружено средство восстановления операционной системы. Выберите язык, раскладку клавиатуры и нажмите кнопкуContinue.В командной строке введите команду:
   fdisk -l /dev/hda
   (/dev/hda— это ваш загрузочный жесткий диск, на который вы собираетесь устанавливать Linux).
   Программаfdiskвыведет среди прочей информации сведения о количестве цилиндров, головок и секторов (CHS) вашего диска, как показано на рис. 1.2. [Картинка: img_17.jpeg] 
   Рис. 1.2.Информация о геометрии диска
   Затем перезагрузитесь с первого компакт-диска (Ctrl+Alt+Del) и в ответ на приглашение загрузчика введите геометрию диска:
   boot: linux hda=C,H,S
   где С — количество цилиндров, H — количество головок и S — количество секторов.
   В нашем случае строка загрузки Linux будет выглядеть так:
   linux hda=2438,255,63
   Теперь инсталлятор будет руководствоваться этими параметрами вместо того, чтобы пытаться определять геометрию диска самостоятельно.Примечание
   Не следует пытаться определять геометрию диска с помощью BIOS, так как способы определения CHS у ОС Linux и BIOS отличаются, и вы можете указать неправильную информацию. Для определения CHS нужно использовать толькоfdisk!
   Если вы поспешили и уже установили Fedora Core 2, в результате чего ваша Windows XP перестала загружаться, обратитесь к сайту Red Hat. По адресуhttp://www.redhat.com/archives/fedora-devel-list/2004-May/msg00908.htmlвы сможете прочитать рекомендации по решению проблемы загрузки Fedora + XP.Особенности и преимущества процесса установки Fedora Core 4
   Собственно особенностей то никаких и нет — все стандартно. А среди преимуществ, на которые упирают даже сами разработчики — это наличие подробнейшего руководства по установке Fedora Core 4.
   1.3.3.Установка загрузчика
   На одном из этапов установки (в некоторых дистрибутивах — ближе к началу, в других — к концу) программа-инсталлятор позволит вам выбрать и установить загрузчик. Стандартными загрузчиками Linux служат LILO (LInux LOader)или GRUB (GRand Unified Boot loader).Сейчас я не буду описывать достоинства и недостатки этих загрузчиков, а только скажу, что я бы выбрал LILO: он мне больше нравится. Потом вы сможете сменить загрузчик в любой удобный для вас момент. Программа установки спросит вас, куда установить загрузчик:
   ? В MBR (Master Boot Record— Главная загрузочная запись);
   ? В первый сектор раздела Linux;
   ? Не устанавливать загрузчик вообще.
   Если вы не планируете загружать Linux посторонним загрузчиком, например, загрузчиком Window NT —NTLoader,то устанавливайте загрузчик в MBR. В этом случае загрузчик получит управление сразу после загрузки компьютера, и вы сможете выбрать любую из установленных на вашем компьютере операционных систем. [Картинка: img_18.jpeg] 
   Рис. 1.3.Выбор загрузчика
   Если вы планируете загружать Linux другим загрузчиком, выберите установку загрузчика в раздел жесткого диска.
   Последний вариант — Не устанавливать загрузчик — следует использовать, если вы хотите загружать Linux с дискеты.
   1.3.4.Продолжение установки
   Выберите класс установки (рис. 1.4). [Картинка: img_19.jpeg] 
   Рис. 1.4.Выбор класса установки
   Класс «Персональный компьютер» подойдет для начинающих пользователей. Будут установлены: графический интерфейс, очень похожий на привычный рабочий стол ОС Windows, и программы, необходимые для домашнего использования компьютера или для организации домашнего офиса. Этот набор программного обеспечения будет занимать около 1.5 Гбайт на жестком диске, а если вы установите сразу две оконных среды (GNOME и KDE), то такой вариант займет около 1.8 Гбайт.
   Класс «Рабочая станция» подойдет, если вы планируете использовать свой компьютер в локальной сети или для разработки программного обеспечения. Класс «Рабочая станция» занимает около 2 Гбайт на жестком диске, а если вы хотите установить данный класс с возможностью выбора графической среды (KDE или GNOME), то такой вариант займет около 2.3 Гбайт.
   Класс «Сервер» нужно использовать, если вы хотите установить и настроить сервер на основе ОС Linux. Будет установлено все необходимое для организации сервера программное обеспечение. Графический интерфейс по умолчанию не устанавливается. Минимальный размер установки — 1.3 Гбайт и еще около 900 Мбайт, если графический интерфейс вам все-таки нужен.
   Я рекомендую вам выбрать класс установки «Выборочная», даже если вы — начинающий пользователь. Этот класс позволяет более гибко настроить вашу систему еще на стадии установки, точно определить устанавливаемые пакеты и их размер.
   После выбора класса установки программа поинтересуется, как вы будете разбивать жесткий диск: автоматически или с использованием программы Disk Druid. Если вы сомневаетесь — выберите автоматическое создание разделов. [Картинка: img_20.jpeg] 
   Рис. 1.5.Уточнение параметров автоматического разбиения
   При выборе автоматического разбиения программа попросит вас уточнить параметры разбиения:
   ? Удалить все Linux-разделы (Remove all Linux Partitions).
   ? Удалить все разделы (Remove all Partitions).
   ? Оставить все разделы и использовать свободное место (Keep all partitions).
   В первом случае инсталлятор удалит все Linux-разделы, если такие имеются на вашем диске. Во втором — будут удалены абсолютно все разделы, включая Windows-разделы. Последний вариант предполагает, что на жестком диске имеется неиспользуемое пространство (не относящееся ни к одному из разделов), которое будет использоваться для установки.
   Если вы выберете возможность просмотра автоматически созданных разделов, то следующий шаг установки вы сделаете с программой разметки диска Disk Druid (рис. 1.6). [Картинка: img_21.jpeg] 
   Рис. 1.6.Программа Disk Druid
   КнопкаСоздатьсоздает новый раздел. Для этого нужно освободить пространство на жестком диске (именно пространство, т.е. область жесткого диска, не принадлежащую ни одному из разделов, а не свободное место).
   Для редактирования параметров раздела предназначена функцияИзменить.Она позволяет изменить точку монтирования раздела, его тип и размер. Если раздел уже был создан на диске, то программа Disk Druid не в состоянии изменить его размер. Для изменения размера нужно удалить этот раздел и создать заново, но с другими параметрами.
   Для создания Linux-раздела нам нужно удалить один из Windows-разделов. Желательно удалять тот, который вы создали с помощью программыPartition Magic,поскольку он не содержит данных. После удаления раздела на его месте нужно создать три раздела:
   1. Linux Native (файловая система ext2 или ext3, точка монтирования/);
   2. Linux Swap (точка монтирования не нужна);
   3. Linux Native (файловая система ext2 или ext3, точка монтирования/home).
   В таблице 1.1 представлена рекомендуемая схема разбиения единственного жесткого диска (/dev/hda)для установки на нем двух ОС: Linux и Windows.

   Схема разбиения диска/dev/hdaТаблица 1.1РазделАктивныйТип/ФСРазмер, ГбКомментарийhda1 (диск С:)ДаПервичный/vfat1.5-2Для самой Windows больше и не нужно, приложения можно поместить на диск D:hda2РасширенныйВсе оставшееся местоНа жестком диске может быть четыре первичных раздела. Дополнительные разделы следует помещать в расширенный раздел. Некоторые ОС (в частности. Windows) требуют, чтобы их раздел был обязательно первичным и активным. Linux может загружаться как с активных, так и с неактивных разделовhda5Логический/ext2 или ext32.5-3Для корневой файловой системы Linux. Нумерация логических разделов начинается с 5!hda6Linux swap128-256МбНе следует этот раздел помещать в конец диска, поскольку операционная система использует его в качестве раздела подкачки. Минимальный размер данного раздела — 32 Мбhda7Логический/ext2 или ext35-10Для пользовательских данных — файловой системы /homehda8 (диск D:)Логический/vfatВсе оставшееся местоЭто диск D: — на него следует устанавливать программы Windows
   Далее программа-инсталлятор предложит вам настроить сеть и брандмауэр (рис. 1.7) — эти шаги можно пропустить, оставив их настройку на потом. Систему безопасности SELinux обязательно выключите или, в крайнем случае, оставьте в режиме предупреждений — в этом режиме она не запрещает недопустимые с ее точки зрения действия пользователя, а протоколирует их. [Картинка: img_22.jpeg] 
   Рис. 1.7.Настройка безопасности
   Вы также можете выбрать дополнительные языки, установить дату и время и ввести пароль суперпользователя (пользователя root). Задаваемый пароль должен быть не короче8 символов. При вводе символы не будут отображаться на экране. Категорически не рекомендуется использовать в качестве пароля что-то вроде 123456, qwerty, password и тому подобное. Подумайте о выборе пароля: он должен быть одновременно легким для запоминания и трудным для подбора. Осторожно! Забыв этот пароль, вы не сможете настраивать систему.
   Постоянно работать под учетной записью root категорически не рекомендуется из соображений безопасности — вы можете нечаянно разнести всю систему. Поэтому нужно добавить хотя бы одного непривилегированного пользователя, который будет выполнять повседневные задачи (набор текста, просмотр видео, программирование), даже если этим единственным пользователем будете вы сами. Учетную запись root нужно использовать только для настройки системы.
   Теперь нужно выбрать пакеты программ для установки (рис. 1.8). Если вы хотите выбрать пакеты самостоятельно, установите переключатель «Уточнить наборы». [Картинка: img_23.jpeg] 
   Рис. 1.8.Выбор групп пакетов
   При индивидуальном выборе пакетов будьте внимательны: некоторые из них для своей работы требуют наличия других пакетов — это называется зависимостью пакетов. Если это первая в вашей жизни установка Linux, не используйте возможность индивидуального выбора пакетов: просто выберите из списка категории программ, которые вас интересуют. После этого останется немного подождать, пока инсталлируются выбранные вами пакеты.
   Обязательно создайте загрузочную дискету. Если вы в очередной раз переустановите ОС Windows, она поместит в MBR собственный загрузчик, который и не подумает загружать вашу ОС Linux. В таком случае загрузитесь с загрузочной дискеты, зарегистрируйтесь как пользователь root и введите командуgrub (илиlilo,если вы используете LILO).
   Для создания загрузочного диска вам понадобится одна отформатированная дискета.
   Я рекомендую использовать графический вход в систему: при этом система X Window (графический интерфейс) будет загружаться автоматически, и вам не нужно будет запускать ее командойstartx.
   Все, установка завершена. Извлеките компакт-диск из привода и перезагрузите компьютер.
   Загрузчик предложит вам список установленных у вас операционных систем. Выберите из него Linux. Если у вас двухпроцессорная машина, то следует выбрать пункт не Linux, a Linux-smp — это SMP-ядро, поддерживающее несколько процессоров.
   1.4.Особенности установки Mandrake 10.0
   Относительно недавно вышла версия 10.1 этого замечательного дистрибутива. В ее состав вошли средства для работы с WiFi и Bluetooth-устройствами, драйверы для ноутбуков IntelCentrino (на этой платформе производится большая часть ноутбуков). Что же касается программного обеспечения, входящего в дистрибутив, то в нем вы найдете:
   ? Ядро версии 2.6.8.
   ? Новые версии графических интерфейсов KDE 3.2.3 и GNOME 2.6.
   ? Компилятор gcc версии 3.4.1.
   ? Web-сервер Apache версии 2.0.50 и интерпретатор PHP 4.3.8.
   ? СУБД MySQL версии 4.0.18.
   ? Новую версию популярного офисного пакета OpenOffice — 1.1.3.
   Загрузите с компакт-диска программу-инсталлятор. Когда появится экран приветствия, вы можете нажать&lt;Ввод&gt;для начала установки в обычном режиме или&lt;F1&gt;для выбора из списка дополнительных режимов (рис. 1.9). [Картинка: img_24.jpeg] 
   Рис. 1.9.Дополнительные режимы установки
   Эти режимы включают:
   ? vgalo— если у вас слабенькая видеоплата и вам нужно произвести установку системы при разрешении 640x480 (16цветов);
   ? text— если вы хотите, чтобы программа установки работала в текстовом режиме;
   ? linux— самая обыкновенная установка;
   ? expert— режим эксперта (вы должны хорошо разбираться в «железе», чтобы устанавливать систему в этом режиме);
   ? rescue— если вы хотите восстановить уже установленную систему.
   Вы также можете ввести дополнительные параметры, например,
   linux mem=512M
   После нажатия Enter будет запущена программа установки в нормальном графическом режиме, и система будет знать, что у вас установлено 512 Мб оперативной памяти.
   В отличие от предыдущей версии Linux Mandrake, выбор класса установки ограничен двумя пунктами:
   ? Установка (Install)
   ? Обновление (Upgrade).
   Если у вас установлен Linux Mandrake версии 8.1 или выше, вы можете его обновить до версии 10.0. Если же у вас установлена версия Mandrake древнее 8.1 или вообще другой дистрибутив,нужно выбрать пункт «Установка».
   При выборе пункта «Установка» старая версия Linux Mandrake, если она была у вас установлена, будет уничтожена. В то же время, если вы хотите изменить разбиение диска или тип файловой системы Linux, вам нужно выбрать именно этот пункт. [Картинка: img_25.jpeg] 
   Рис. 1.10.Выбор уровня безопасности
   После выбора раскладки клавиатуры инсталлятор Linux Mandrake (который, кстати, называется DrakeX) предложит вам установить уровень безопасности. Помните, чем выше уровень безопасности, тем неудобнее работать в системе пользователю. Для домашней машины (на которой вы будете экспериментировать) подойдет средний уровень, а для сервера сети не лишним будет и повышенный. Не устанавливайте параноидальный уровень безопасности при установке системы: вам потом будет трудно ее настроить. Данный уровень подойдет для систем, относящихся к классу «поставил и забыл»: программных маршрутизаторов или шлюзов, администрирование которых не выполняется или выполняется очень редко. Обычно такие системы таятся где-нибудь в углу серверной комнаты и работают круглосуточно, например, передавая пакеты из одной локальной сети в другую.
   Вы сможете полностью настроить систему, не дожидаясь для этого перезагрузки (рис. 1.9). Настройке поддаются:
   ? Раскладка клавиатуры (Keyboard)
   ? Страна (Country/Region)
   ? Часовой пояс (Timezone)
   ? Тип мыши (Mouse)
   ? Тип принтера (Printer)
   ? Тип звуковой платы (Sound card)
   ? Параметры видео подсистемы (Graphical interface)
   ? Параметры сети (Network)
   ? Уровень безопасности (Security level)
   ? Параметры брандмауэра (Firewall)
   ? Загружаемые сервисы (Services)
   ? Конфигурация начального загрузчика Linux (Bootloader)
   ? Параметры других устройств, например, ISDN-платы или TV-тюнера. [Картинка: img_26.jpeg] 
   Рис. 1.11.Настройка параметров системы
   Обычно инсталлятор правильно определяет параметры видеосистемы вашего компьютера, но в некоторых случаях нужно уточнить тип вашей видеокарты, ее модель, тип монитора. Обязательно нажмите кнопкуПроверитьдля проверки выбранного видеорежима.
   Если вы хотите запускать систему X Window автоматически при загрузке Linux, нажмите кнопкуПараметры (Options).Если же ваша система будет использоваться в качестве сервера, автоматическая загрузка X Window не нужна.
   В параметрах сети вы можете попросить инсталлятор автоматически распознать ваши сетевые параметры, если это возможно. Если же он не определил параметры вашей сетевой платы или модема автоматически, попробуйте настроить эти сетевые устройства в режиме эксперта. При этом вам нужно знать следующие параметры:
   ? IP-адрес этого компьютера и его имя, которое должно быть прописано на сервере DNS — эту информацию вы можете уточнить у администратора вашей сети;
   ? IP-адрес шлюза;
   ? IP-адрес сервера DNS.
   Инсталлятор позволяет настроить традиционное соединение по модему, по локальной сети, ISDN/ADSL-соединения и даже выделенное соединение.
   Наконец, вы сможете даже заняться администрированием системы прямо в процессе установки (рис. 1.12), отключив не нужные пока сервисы, чтобы система загружалась быстрее. [Картинка: img_27.jpeg] 
   Рис. 1.12.Выбор служб, запускаемых при загрузке системы
   Вы не знаете, что именно стоит отключить? Думаю, в этом вам поможет таблица 1.3 (см. п. 1.9).
   Откажитесь от автоматического обновления системы, и установка завершена. Нажав кнопку Дополнительно, вы можете создать дискету для клонирования Linux. Эта дискета может понадобиться, если у вас есть несколько одинаковых компьютеров, на которые нужно установить Linux. Я же рекомендую создать эту дискету, даже если у вас всего один компьютер — дискета для клонирования существенно облегчит переустановку системы на этом компьютере. Конечно, вы не будете переустанавливать Linux так же часто, как Windows, но кто его знает?
   Чтобы использовать дискету клонирования, загрузитесь с первого CD, когда увидите приветствие программы установки, нажмите&lt;F1&gt;и введитеdefcfg="floppy".
   1.5.Проблемы при установке
   1.5.1.Конфликты Fedora Core 1 и 2 с различным оборудованиемМатеринские платы ASUS
   На материнскую плату ASUS серии P4P800 Fedora Core 2 не устанавливается. Пока данная проблема не решена. Остается сменить либо материнскую плату, либо дистрибутив. Следить заходом устранения ошибки можно по адресуhttps://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=121819.LCD-мониторы
   На некоторых LCD-мониторах не удается запустить программу установки в графическом режиме. В этом случае в ответ на приглашение boot введите параметр nofb:
   linux nofbНоутбуки SONY
   На некоторых моделях ноутбуков SONY VAIO возникают проблемы с установкой Fedora Core 2, решить которые поможет параметр ядра:
   linux pci=off ide1=0x180,0x386Не работает мышь
   В процессе установки Fedora Core 2 обыкновенные COM-мыши (последовательные) не работают. Они начнут работать после завершения установки, а пока обходитесь клавиатурой или подключите PS/2-мышь.
   1.5.2. Fedora Core:не удается войти в систему как root в графическом режиме
   Включена система безопасности SELinux. При установке некоторым файлам в домашнем каталоге root назначается ошибочный контекст безопасности. Для исправления этой ошибочки зарегистрируйтесь в консоли как root и введите команду:
   setfiles /etc/security/selinux/file_contexts /root
   1.5.3.Ошибка Signal 11
   Возникает при сбое шины памяти вашего компьютера. Это может произойти, если ваше аппаратное обеспечение не поддерживается Linux или драйвер для этого аппаратного обеспечения работает некорректно. Список поддерживаемых аппаратных средств находится по адресуhttp://bugzilla.redhat.com/hwcert,а по адресуhttp://www.bitwizard.nl/sig11вы сможете более подробно прочитать об ошибке Signal 11.
   1.5.4.Не определяется мышь
   Если программа установки не смогла определить мышь, вы увидите соответствующее сообщение. При этом вам будет предложено продолжить установку в текстовом режиме, который не требует мыши. Проверьте, работает ли мышь вообще (на другом компьютере).
   1.5.5.Проблемы с переходом в графический режим
   Программа установки Linux работает в графическом режиме. Если у вас старая видеокарта, не поддерживающая разрешения 800x600,или старый монитор, вам придется запускать инсталлятор в режиме с низким разрешением. В ответ на приглашениеboot:введитеlowres— программа установки будет использовать разрешение 640x480.
   1.5.6.Проблемы при загрузке
   ОС Linux может использовать разделы, которые расположены дальше 1024-го цилиндра, но не может загружаться с таких разделов. Поэтому, если вы не можете создать Linux-раздел«ближе» к началу диска, создайте небольшой раздел для точки монтирования/boot (не более 100 МБ), который нужно разместить до 1024-го цилиндра. Второй вариант — загрузка с дискеты.
   1.5.7.Проблемы с графическим экраном загрузчика
   1. GRUB: отредактируйте файл/boot/grub/grub.conf,закомментировав строку splashimage.
   2. LILO: отредактируйте файл/etc/lilo.conf,удалив строку message=/boot/message. Изменения вступят в силу после введения командыlilo.
   1.5.8.Не загружается система X Window
   Зарегистрируйтесь в системе и введите командуstartx.Если при запуске X Window возникла ошибка, запустите конфигуратор системы X Window.
   1.5.9.Я забыл пароль пользователя root
   Бывает… Перезагрузите компьютер и в строке приглашения загрузчика lilo введите linux single. Будет запущен однопользовательский режим. Для изменения пароля введите командуpasswd root.
   1.5.10.У меня больше оперативной памяти!
   Иногда Linux не может точно определить объем оперативной памяти. Например, у вас установлено 128 Мбайт, а Linux видит только 64. Для исправления этого в файл/etc/lilo.confдопишите строку:
   append="mem=128M"
   Для того, чтобы изменения вступили в силу, введите командуlilo.
   1.5.11.Не работают принтер или звуковая плата
   В более ранних версиях Red Hat Linux настройка принтера происходила при установке операционной системы. Теперь принтер и звуковую плату нужно конфигурировать отдельно. В Red Hat Linux для этого служат графические конфигураторыredhat-config-printerиsndconfigсоответственно. В Fedora Core —system-config-printerиsystem-config-soundcard.
   1.6.Как удалить Linux
   Любой дистрибутив Linux удаляется в два этапа:
   1. Удаление загрузчика Linux. Проще всего восстановить оригинальный загрузчик Windows 98, введя командуfdisk /mbrв командной строке Windows. Если у вас Windows 2000/XP, восстановить оригинальный загрузчик помогут командыfixbootиfixmbr— именно в таком порядке. Удалить загрузчик LILO можно и с помощью самого LILO: зарегистрируйтесь как пользователь root и введите командуlilo -U.
   2. С помощью программы установки Linux удалите разделы Linux. Для этого выберите тип установки «Установка» (Install), затем выберите ручное разбиение диска, удалите Linux-разделы, сохраните таблицу разделов и перезагрузите машину, нажав Reset.
   1.7.Системы с двойной загрузкой
   Прежде чем устанавливать на своем компьютере вторую операционную систему, обязательно сделайте резервное копирование важных данных, потому что процесс установки операционной системы включает в себя переразбиение жесткого диска на разделы и форматирование созданных разделов. Переразбиение жесткого диска необходимо, потому что Linux и Windows используют разные файловые системы. Хотя существуют средства установки Linux в раздел FAT/FAT32 — Lin4Win, но я не рекомендую их использовать, т.к. в этом случае Linux работает крайне нестабильно и медленно.
   Рассмотрим два наиболее распространенных варианта установки нескольких операционных систем:
   1. Вы устанавливаете Windows 9x и Linux.
   2. Вы устанавливаете Windows NT, Windows 9x и Linux.
   1.7.1.Установка Windows 9x и Linux
   Главное правило при такой установке заключается в том, что сначала следует устанавливать Windows 9x, и только после этого Linux. Дело в том, что при установке Windows 9x перезаписывает главную загрузочную запись MBR (Master Boot Record)и загрузить Linux с диска вы уже не сможете. При этом очень напрашивается следующий совет: создайте загрузочную дискету для Linux! Если вы в очередной раз переустановите Windows, без этой дискеты загрузить Linux не удастся.
   Что делать, если вы переустановили Windows и Linux больше не загружается:
   ? У вас есть загрузочная дискета для Linux. Загрузитесь, используя эту дискету. Затем зарегистрируйтесь в системе как пользователь root и введите командуlilo.Затем перезагрузите машину (командаreboot).
   ? У вас нет загрузочной дискеты: используйте программуloadlin— ее описание будет приведено ниже.
   ? Нет загрузочного диска и нет программыloadlin:переустановите Linux — после установки Windows, естественно. При установке Linux не форматируйте разделы, и ваши данные останутся неповрежденными.
   Оптимальным загрузчиком при данной схеме установки (Windows 9x + Linux) будет LILO. Я бы не рекомендовал использование каких-либо посторонних загрузчиков, как бы стабильно они ни работали. Во время инсталляции Linux программа установки спросит, куда устанавливать LILO — выберите MBR.
   В случае деинсталляции Linux (после того, как вы уже удалили разделы Linux) восстановить MBR, то есть удалить LILO, поможет командаfdisk /mbr.При этом нужно использовать программуfdiskиз комплекта загрузочного диска Windows.
   1.7.2.Установка Windows 9x, Windows NT/2000/XP и LinuxПервый способ
   В этом способе используется загрузчикNTLoader.Выполните установку Windows 2000 в раздел NTFS, a Windows 9x — в раздел FAT/FAT32. Не забудьте приготовить четыре системных дискеты для восстановления! Напомню, что если вы хотите установить Windows 95, то ее нужно устанавливать первой, а потом Windows 2000. При установке Windows 98 и Windows 2000 порядок установки не имеет значения.
   Устанавливать Linux нужно после установки Windows 2000. При этом необходимо учесть, что раздел Linux должен находиться до 1024 цилиндра! Это связано с «барьером 1024 цилиндра» — Linux может использовать разделы, расположенные после цилиндра 1024, но не может загружаться с таких разделов. В последних версиях Linux данная проблема устранена, но рассматриваемый способ установки требует, чтобы вы создали раздел Linux до цилиндра 1024 — иначе вам придется загружать Linux с дискеты.
   Еще раз напоминаю: обязательно создайте загрузочную дискету для Linux. При установке LILO выберите MBR — Linux перезапишет главную загрузочную запись. Далее загрузите с четырех загрузочных дискет Windows 2000 и выберите пункт «Recover» в меню загрузчика и режим «Command mode». Затем зарегистрируйтесь в системе как Administrator. Выполните командыfixbootиfixmbr — теперь Windows 2000 будет нормально загружаться.Примечание
   Утилитыfixbootиfixmbrиспользуются в Windows 2000 для восстановления главной загрузочной записи (MBR). Командаfixmbrпрактически аналогична командеfdisk /mbrв Windows 9x.
   Затем загрузитесь с системной дискеты Linux и войдите в систему как root. Откройте в любом текстовом редакторе файл/etc/lilo.conf.В начале файла есть ссылка на загрузочный раздел по умолчанию, например,/dev/hda.Вам нужно изменить это значение на диск и раздел, в который была установлена ОС Linux, например/dev/hdb1.
   Введите командуliloи увидите, что загрузочный раздел не является первым на диске — именно это вам и нужно. В этом случае загрузочная запись Windows 2000 не будет повреждена. Запишите загрузчик Linux в файл/bootsect.lnx:
   # dd if=/dev/hdb1 bs=512 count=1 of=/bootsect.lnx
   Теперь этот файл нужно скопировать на дискету:
   # mount -t msdos /dev/fd0 /mnt
   # copy /bootsect.lnx /mnt
   # umount /mnt
   Перезагрузите Linux командойrebootи загрузите Windows 2000. Скопируйте файлbootsect.lnxв корневой каталог диска С: и присвойте ему атрибутread-only.Добавьте строку в файлboot.ini:
   С:\bootsect.lnx ="Linux"
   В результате при перезагрузке компьютера вы сможете загрузить Linux с помощьюNTLoader.Второй способ
   Существует более простой способ установки Linux и любой операционной системы семейства Microsoft Windows — Windows 9x, NT, 2000. Сначала нужно установить все ОС Windows, а потом установить Linux. При этом вместо начального загрузчика будет использоваться неNTLoader, a LILO.В этом случае вы получите двойное меню: сначала нужно выбрать между загрузкой Linux и Windows, а потом выбрать нужную вам ОС Windows — Windows 9x или NT/2000 — в зависимости оттого, какую систему вы установили, кроме Windows NT. Второе меню — это как раз меню загрузчикаNTLoader.Использование loadlin
   В этой книге я просто не мог не упомянуть о компактном загрузчикеloadlin,который позволяет загрузить Linux из-под DOS или Windows 95.
   Если вы используете Windows 98,loadlinработать у вас не будет — нужно перезагрузиться в режиме MS DOS. Кроме этого, следует учесть, что при использованииloadlinмогут возникнуть проблемы с разделами FAT32. В этом случае создайте загрузочную дискету DOS (format a: /s)и в autoexec.bat этой дискеты пропишитеloadlin.Загрузить Linux из-под операционных систем Windows 98, Me или Windows 2000/NT вам не удастся в любом случае.
   Использоватьloadlinя рекомендую лишь в том случае, если при очередной переустановке Windows оказался «затертым» MBR (а вместе с ним и LILO), а системную дискету Linux вы не создали. Вызов программыloadlinимеет следующий формат (описание параметров приведено в табл. 1.2):
   loadlin&lt;ядро&gt;&lt;root=корневая_ФС&gt;&lt;опции&gt;
   или
   loadlin @файл_с_параметрами

   Параметры программыloadlinТаблица 1.2ПараметрОписаниеЯдроЯдро, которое вы используете. Если у вас на данный момент нет именно того ядра, которое было установлено, можно взять практически любое (лучше не самое древнее). Обычно ядро можно взять на компакт-диске с дистрибутивом Linux. Оно вам потребуется всего один раз — нужно только загрузиться и перезаписать lilo (команда lilo)root=корневая_ФСКорневая файловая система, например root=/dev/hda3опцииОпции, которые будут переданы ядру во время загрузки. Обычно используется ro vga=normal@файл_с_параметрамиЕсли параметры, которые вы передаете loadlin (а не ядру!) окажутся слишком длинными, то их можно записать в отдельный файл, а затем указать его имя в качестве параметра
   Совет: можно включить загрузку Linux в стартовое меню DOS. Для этого отредактируйте свойconfig.sysследующим образом (см. листинг 1.1).
   Листинг 1.1. Фрагмент файла config.sys
   [MENU]
   MENUIТЕМ=DOS, Load DOS
   MENUITEM=LINUX, Load Linux
   MENUDEFAULT=DOS,5

   [LINUX]
   install=c:\loadlin\loadlin.exe c:\loadlin\kernel\vmlinuz root=/dev/hda3 ro vga=normal

   [DOS]
   ;ваш предыдущий config.sys
   1.8.Первый запуск Linux
   Если вы выбрали для входа в систему графический режим (или инсталлятор выбрал его сам, ни о чем не спросив), то вы увидите графический экран с полем ввода имени и пароля. Зарегистрируйтесь в системе (лучше под тем именем, которое завели для обычного пользователя; используйте root, только если обычных учетных записей у вас еще нет), и вы увидите рабочий стол той оконной среды, которую установили в качестве среды по умолчанию, внешне довольно похожий на рабочий стол Windows.
   Как же так, вы ведь слышали, что настоящие линуксоиды работают в среде командной строки? Сейчас найдем и командную строку.
   Вы знаете, что консолью, или терминалом (для персонального компьютера эти понятия — синонимы) называются устройства ввода-вывода, предназначенные для общения системы с пользователем, то есть клавиатура и монитор. В UNIX-подобных системах существует понятие виртуальных консолей — консолей, по очереди занимающих физически одни и те же монитор и клавиатуру. На каждой из них может быть открыт отдельный сеанс работы пользователя, запущены свои приложения, в общем, они представляют собой почти независимые друг от друга вычислительные системы.
   В большинстве дистрибутивов Linux по умолчанию обслуживается шесть текстовых виртуальных консолей, седьмая — графическая. На ней вы и находитесь. Чтобы переключиться с нее на первую текстовую консоль, нажмите комбинацию клавиш Ctrl+Alt+F1 (на шестую — Ctrl+Alt+F6).
   В ответ на приглашение программыlogin:введите root и нажмите&lt;Ввод&gt;.Потом введите пароль, и ваш сеанс работы в текстовой консоли начат.
   Информацию о сетевом имени машины, версии ОС, архитектуре можно получить по командеuname -а.
   Если учетной записи для обычного пользователя у вас еще нет, самое время ее завести. Введите команду
   #useradd&lt;имя&gt;
   Если вам ответили «command not found», то, значит, в вашей системе эта команда называетсяadduser.
   Вы добавили нового пользователя. Однако это еще не все, нужно указать его пароль:
   #passwd&lt;имя&gt;
   Теперь можно регистрироваться под новым именем на другой виртуальной консоли. Чтобы с текстовой консоли переключиться на другую текстовую, нажмите комбинацию Alt+Fn, где n — число от 1 до 6. Вы снова увидите приглашениеlogin:.
   Зарегистрировались? Обратите внимание на строку приглашения. На той консоли, где вы зарегистрировались как root, она оканчивается символом #, а для любого обычного пользователя — символом $. Кроме этого символа, приглашение обычно состоит из имени пользователя, имени системы и текущего каталога, причем вид его можно изменить, как только вы узнаете, как это делать. В дальнейших примерах строки, начинающиеся с # или будут обозначать вводимую команду, а строки без такого символа — ее сообщения.
   Теперь убедитесь сами, что Linux — действительно многозадачная и многопользовательская система, то есть, в отличие от Windows, несколько пользователей могут работать одновременно. Спросите, кто сейчас работает в системе, введя командуwho.
   Вы увидите что-то вроде:
   root tty1&lt;дата и время начала сеанса root&gt;
   ivan tty2&lt;дата и время начала сеанса ivan&gt;
   root :0&lt;дата и время начала сеанса root&gt;
   &lt;на графической консоли&gt;
   ttyN— это номер виртуальной текстовой консоли.
   Если вы потерялись и хотите узнать, на какой консоли находитесь сейчас, введите командуtty.Если вы забыли, под каким именем зарегистрировались на текущей консоли, введите командуwhoami.Командаwпокажет не только работающих сейчас пользователей, но и запущенные ими задачи.
   Листать экран можно комбинациями клавиш Shift+PgUp и Shift+PgDn.
   Для копирования текста в командную строку используйте мышь: протаскивание мыши при нажатой левой кнопке выделяет фрагмент, щелчок правой кнопки вставляет его в текущую позицию курсора на любой виртуальной текстовой консоли.
   Если вы хотите, не сходя с этой консоли, поработать под именем другого пользователя, введитеsu&lt;имя&gt;.По умолчанию в качестве имени подставляется root. Обычно это нужно для того, чтобы быстро выполнить какое-то администраторское действие. Возвращайтесь к работе под своим именем по командеexit.
   Чтобы переключиться обратно на графическую консоль, нажмите Alt+F7.
   В графическом режиме тоже можно не только щелкать мышью по значкам, но и вводить команды. Для этого запустите виртуальный терминал (рис. 1.13) — графическое приложение, в окне которого можно работать в режиме командной строки. [Картинка: img_28.jpeg] 
   Рис. 1.13.Окно виртуального терминала
   Количество виртуальных терминалов, в отличие от количества виртуальных консолей, не ограничено ничем, даже традицией.
   Чтобы завершить сеанс работы на виртуальном терминале или на виртуальной консоли, введите командуexit (на виртуальной консоли можно такжеlogout)или нажмите комбинацию клавиш Ctrl+D.
   Завершение работы одного пользователя не приводит к остановке всей системы. Чтобы выключить машину, нужно с правами суперпользователя отдать команду
   # shutdown -h 19:00 [Конец рабочего дня]
   При этом за несколько минут до указанного времени всем, кто работает в системе, будет разослано предупреждающее сообщение «Конец рабочего дня», после чего системабудет корректно остановлена. Краткой формой этой команды служитhalt,останавливающая систему сейчас же и без предупреждения. Перезагрузиться можно командойreboot.
   1.9.Стандартные сервисы Linux
   Описание стандартных сервисов Linux приведу в виде таблицы (см. табл. 1.3).

   Стандартные сервисы Linux Таблица 1.3СервисОписаниеНужен?anacron, crondПланировщики заданий, запускающие по графику определенные программыДаарmdОтслеживает состояние батарей ноутбука. У вас стационарный компьютер? Тогда смело отключайте этот сервис Конечно, он вам понадобится, если у вас умный ИБП; тогда apmd может корректно завершить работу системы, если пропало напряжение, а батарея ИБП разряженаatdЕще один планировщик заданийautofsСредство автоматического монтирования сменных носителей (CDROM, дискета)Даchargen, chargen-upВнутренний сервис демона xinetd, генерирующий символы с определенным интервалом времени и посылающий его по сетиcpuspeedДинамическое управление скоростью процессораcupsСистема печати в Unix-подобных ОС (Common Unix Print System). Принтер у вас есть? Тогда она нужнаcups-config-daemonДемон для конфигурирования cupsdialdАвтоматический дозвон к провайдеруgpmПоддержка мыши в консоли LinuxДаgssftpFRP-сервис, входящий в состав суперсервера xinetd (гл.11) и использующий авторизацию на Kerberos-сервереirdaПоддержка работы с инфракрасным портомirqbalanceОсуществляет балансировку прерываний на многопроцессорных системахInternetУстанавливает соединение с провайдером при загрузке системы и обрывает его при завершении работыiptablesМежсетевой экранhaldaemonСобирает информацию об оборудованииkeytableЗагружает раскладку клавиатуры, указанную в файле /etc/sysconfig/keyboardДаklogdПротоколирует сообщения ядра в файле /var/log/kernelДаkudzuИщет изменения в аппаратной конфигурации компьютера. Вполне может запускаться вручную. Обычно запуск kudzu необходим один раз — после установки системы, потом его можно отключить и запускать только при установке новых устройств в компьютер (или удалении ранее установленных)lisaДемон, собирающий информацию о ресурсах сети MicrosoftlinuxconfОрганизовывает выполнение различных задач конфигурирования при загрузке системыmdmonitorМониторинг и управление программным RAIDnamedСервер DNSnetfsОбеспечивает монтирование удаленных сетевых файловых систем (NFS, SMB, NCP (NetWare))networkПоддержка сети. Этот сервис должен быть включен всегда, поскольку даже графическая система и система печати в Linux нуждаются в немДаnfslockМеханизм блокирования файлов NFSnumlockВключение режима клавиатуры Num Lockoki4daemonПоддержка OKI 4w-принтеровpcmciaПоддержка устройств PCMCIAportmapНеобходим для приложений, использующих удаленный вызов процедур RPC. Нужен для NFS и NIS (Network Information Service)psacctСлужба учета процессовhttpd, proftpd, wu-ftpd, sendmail, postfixWeb-, FTP-и почтовые серверы. Пока включать их не нужно, поскольку они не настроены и будут дополнительной «дырой» в безопасности вашей системыrandomУлучшает качество генерации случайных чиселДаrawdevicesНе вдаваясь в технические подробности, просто отключите этот сервисreadahead, readahead_earlyСервисы, позволяющие выполнять предварительную загрузку программ в оперативную памятьrhncdВ дистрибутивах Red Hat и Fedora — демон, который периодически подключается к серверу Red Hat на предмет обновленийsmartdМониторинг жёстких дисков, с использованием протокола S.M.A.R.TsaslauthdОбработка запросов аутентификацииspamassassinСервис, предназначенный для борьбы со спамомsshdСервер, предназначенный для безопасного удаленного администрирования системыsyslogСлужба ведения системных журналовsmbЕсли вы планируете работать в сети Microsoft, включите этот сервис, но только после его настройки, описанной в административном разделе. А пока отключитеДаwinbindИспользуется для аутентификации Samba-пользователей в домене NTxfsСервер шрифтов, нужен для системы X WindowДаnamedСервер DNSypbindСлужба, используемая для обеспечения доступа к NIS-серверуyumСервис, осуществляющий обновление системы в автоматическом режиме
   Узнать, какие сервисы установлены у вас в системе, можно воспользовавшись системной утилитойsystem-config-services (пункт менюСистемные параметры->Настройка сервера->Службы)— это в Fedora Core. Кроме того, можно воспользоваться консольной утилитойntsysv.
   1.10.Справочная система
   «Родной» для UNIX справочной системой, аналогом Справки Windows, служат страницы интерактивного руководства (manual pages, man-страницы). Ими снабжена практически каждая программа, важный конфигурационный файл или системный вызов. Это обычные текстовые файлы, содержащие сведения о назначении, синтаксисе, опциях команды, формате файла, примеры их применения, имена и URL разработчиков. Обычный дистрибутив содержит тысячи страниц такой документации. Просматривают ее командойman.Например,man man— это вызов справки о самой командеman.
   При установке каждого программного пакета включенные в его состав man-страницы копируются в стандартные каталоги, так что программаmanлегко их находит. В этих каталогах страницы сгруппированы в секции по темам. Перечислим эти секции в порядке просмотра программойman:
   1Команды пользователя
   8Системные команды
   2Системные вызовы
   3Библиотечные вызовы (подпрограммы)
   4Устройства
   5Форматы файлов
   6Игры
   7Разное
   9Ядро (kernel internals)
   Так что, если вас интересует справка не о консольной командеexit,а о системном вызовеexit(),запрашивайте ее командойman 2 exit.
   Чтобы ознакомиться с содержанием раздела, введите команду
   man&lt;номер_раздела&gt; intro
   Вот несколько самых употребительных команд управления выводом man-справки на экран:
   &lt;Ввод&gt;вывод следующей строки текста
   &lt;Пробел&gt;вывод следующего экрана текста
   &lt;Q&gt;выход из программы
   &lt;/&gt;образец&lt;Ввод&gt;поиск образца
   &lt;N&gt;повторение поиска.
   Альтернативой команде man служит гипертекстовая справочная система info. Ссылки обозначены звездочками (*), и перемещает по ним клавиша&lt;Tab&gt;.Чтобы пройти по ссылке, нажмите&lt;Ввод&gt;.Чтобы перейти на следующую или предыдущую страницу, нажмите&lt;N&gt;или&lt;P&gt;соответственно. Чтобы попасть на один уровень иерархии страниц вверх, нажмите&lt;U&gt;.И клавиша&lt;Q&gt;завершает работу с программой info.
   Сверхкраткую (одна строка) справку о командах дает команда
   whatis&lt;ключевое_слово&gt;
   Для работы ей нужна база данных о системных командах, создаваемая программойmakewhatis.
   Если точного имени команды вы не знаете, но примерно догадываетесь, какие фрагменты слов могут встретиться в ее имени или кратком описании, вам поможет командаapropos,производящая поиск в той же базе по фрагментам слов. Например, отдав команду
   $ apropos config
   вы получите список команд, имеющих отношение к конфигурированию системы и различных служб.
   Командаmanс ключом-kтоже умеет выполнять поиск по ключевым словам. Если вы хотите узнать, какие программы имеют отношение к некоторому системному файлу (конфигурационному или журнальному, например,/etc/passwd),введите команду
   $ man -k passwd
   Вы получите список man-страниц по командам, функциям, формата файлов и т.п., на которых встречается слово «passwd». В общем, поиск информации в справочной системе UNIX очень похож на поиск в Интернете: находите что-то похожее и переходите по ссылкам все ближе к истине.
   Есть и командаhelp:она выводит справку о встроенных командах командной оболочки (о командных оболочках сказано в гл.3).
   Наконец, правильно написанные команды понимают ключи--helpи--usage,с которыми выдают краткую справку о себе.
   К сожалению, многие страницы документации на русский язык пока не переведены. Linux — ОС некоммерческая, и переводом занимаются добровольцы на общественных началах.Может быть, со временем к ним присоединитесь и вы? А пока загляните на
   http://www.linuxshare.ru/projеcts/trans/index.html
   Глава 2
   Файловая система LINUX
   2.1.Видимая сторона файловой системы
   С точки зрения пользователя, файловая система — это логическая структура каталогов и файлов. В отличие от Windows, где каждый логический диск хранит отдельное дерево каталогов, во всех UNIX-подобных системах эта древовидная структура растет из одного корня: она начинается с корневого каталога, родительского по отношению ко всем остальным, а физические файловые системы разного типа, находящиеся на разных разделах и даже на удаленных машинах, представляются как ветви этого дерева.
   2.1.1.Имена файлов и каталогов
   Имена файлов и каталогов могут иметь длину до 255 символов. Символы «/» (слэш) и символ с кодом 0 запрещены. Кроме того, ряд символов имеет специальное значение для командного интерпретатора, и их использование не рекомендуется. Это символы:
   ~ ! @ # $& % * ( ) [] {} ' " \ : ;&gt;&lt; `пробел
   Если вам все-таки нужно употребить один их этих символов в имени файла, то при указании его имени в команде этот символ нужно экранировать знаком «\» (обратный слэш)или заключать все имя в двойные кавычки. Например, вы хотите вывести на экран командойcatсодержимое текстового файла с именемmy file,содержащим символ пробела:
   $ cat my file #неправильно
   cat: my: No such file or directory
   cat: file: No such file or directory

   $cat "my file" #правильно
   Привет!
   $cat my\ file #правильно
   Привет!
   Знак # — это символ комментария для командного интерпретатораbash,о котором подробнее рассказано в главе 8. Командный интерпретатор игнорирует все символы от этого знака до конца введенной строки. Возможность комментировать не слишком полезна при вводе команд с консоли, но неоценима при написании командных сценариев, о которых мы еще будем говорить.
   Заметьте, что точки среди специальных символов нет, и имена вродеthis.is.а.text.file.containing.the.famous.string.hello.worldдопустимы и широко распространены. Часто последняя отделенная точкой часть имени используется подобно «расширению имени» в Windows, обозначая файл определенного типа, но это обозначение несет смысл только для человека. Так, человеку имя файлаivan_home.tar.gzподсказывает, что это домашний каталог пользователя ivan, упакованный архиваторомtarи сжатый компрессоромgzip.
   Если имя файла начинается с точки, то этот файл считается скрытым: некоторые команды его «не видят». Например, введя в своем домашнем каталоге команду просмотра содержимого каталогаlsс ключом-а,означающим «показывать скрытые файлы», вы увидите больше файлов, чем введя ту же команду без ключей.
   Linuxразличает регистр символов в именах файлов: так, в одном каталоге могут находиться два разных файлаREADMEиReadme.Кстати, файлы с подобными именами обычно содержат информацию, действительно достойную прочтения.
   Имена каталогов строятся по точно тем же правилам, что и имена файлов.
   Полным именем файла (или путем к файлу) называется список вложенных друг в друга каталогов, заканчивающийся собственно именем файла. Начинаться он может с любого каталога, потому что в древовидной структуре между любыми двумя узлами существует путь. Если этот список начинается с корневого каталога, то путь называется абсолютным. Если с любого другого — то относительным (по отношению к этому каталогу).
   Корневой каталог обозначается символом «/» (слэш), и этим же символом разделяются имена каталогов в списке. Таким образом, абсолютным именем файлаREADMEв домашнем каталоге пользователя den будет/home/den/README.
   В каждом каталоге существуют два особых «подкаталога» с именами «две точки» и «точка». Первый из них служит указанием на однозначно определенный родительский каталог, а второй — на сам данный каталог. Для корневого каталога, у которого нет родителя, оба эти «подкаталога» указывают на корневой каталог. С помощью этих имен образуются относительные имена файлов. Так, именем вышеупомянутого файлаREADMEотносительно домашнего каталога/home/ivanпользователяivanбудет../den/README.
   2.1.2.Назначение основных системных каталогов
   В системных каталогах находятся файлы, необходимые для управления и сопровождения системы, а также стандартные программы. Их имена, расположение и содержание почти одинаковы почти во всех ОС Linux, поэтому эти каталоги называют также стандартными. Впрочем, на данный момент эпитет «стандартные» отражает скорее благие пожелания, чем действительность: иерархия каталогов одинакова только для дистрибутивов, связанных единством происхождения, а исторически сложившиеся различия создают опасность несовместимости разных дистрибутивов. Стандарт файловой иерархии для UNIX-подобных систем разрабатывает группа добровольцев, и с его текущей версией можно ознакомиться по адресуhttp://www.pathname.com/fhs.
   Краткое описание основных каталогов линии Red Hat и Fedora Core сведено в табл. 2.1.

   Стандартные каталоги Таблица 2.1КаталогНазначение/binОсновные программы, необходимые для работы в системе: командные оболочки, файловые утилиты и т.п./sbinКоманды для системного администрирования, а также программы, выполняемые в ходе загрузки/bootФайлы, необходимые для загрузки системы (образ ядра)/homeДомашние каталоги пользователей, кроме root/devФайлы устройств/etcФайлы настроек: стартовые сценарии, конфигурационные файлы графической системы и различных приложений/libСистемные библиотеки, необходимые для основных программ, и модули ядра/lost+foundВосстановленные после аварийного размонтирования части файловой системы/mediaСюда обычно монтируются съёмные носители: компакт-диски, flash-накопители/mntВременные точки монтирования жестких дисков Использовать этот каталог необязательно: подмонтировать файловую систему можно к любому другому каталогу/optДополнительные пакеты программ. Если программа, установленная сюда, больше не нужна, то достаточно удалить ее каталог без обычной процедуры деинсталляции/procВиртуальная файловая система, дающая доступ к информации ядра (например, выведите на экран файл /proc/cpuinfo). Другие файлы в этом каталоге в каждый момент времени содержат информацию о выполняющихся в этот момент программах/rootДомашний каталог суперпользователя. Домашние каталоги всех остальных могут находиться на отдельном разделе, но /root должен быть в корневой файловой системе, чтобы администратор всегда мог войти в систему для ремонтных работ/tmpВременные файлы/varЧасто меняющиеся данные: системные журналы и протоколы приложений, замки. Почтовые ящики, очереди печати и т.п./usrПрактически все остальное: программы, исходные коды, документация. Сюда по умолчанию устанавливаются новые программы
   Скорее всего, в ваш дистрибутив включена man-страницаhier,подробно описывающая назначение этих каталогов и их основных подкаталогов.
   2.1.3.Типы файлов
   С точки зрения UNIX-подобных ОС, файл представляет собой поток или последовательность байтов. Такой подход позволяет распространить понятие файла на множество ресурсов не только локального компьютера, но и удаленного, связанного с локальным сетью любого рода. Доступ к любому такому ресурсу осуществляется через универсальный интерфейс, благодаря чему запись данных в файл, отправка их на физическое устройство или обмен ими с другой работающей программой происходит аналогично. Это очень упрощает организацию данных и обмен ими.
   В ОС Linux можно выделить следующие типы файлов:
   ? обычные файлы — последовательность байтов (текстовые документы, исполняемые программы, библиотеки и т.п.);
   ? каталоги — именованные наборы ссылок на другие файлы;
   ? файлы физических устройств, подразделяющихся на:
    • файлы блочных устройств, драйверы которых буферизуют ввод-вывод с помощью ядра и
    • файлы байт-ориентированных, или символьных, устройств, позволяющих связанным с ними драйверам выполнять буферизацию собственными средствами;
   ? символические ссылки (symlink, symbolic link);
   ? именованные каналы (named pipes);
   ? гнезда (sockets).Обычные файлы и каталоги
   Свойства (атрибуты) файлов и каталогов можно вывести на терминал с помощью командыlsс ключом-l:
   $ls -l /home/den/README
   -rwxr-xr-- 1 den users 0 Feb 14 19:08 /home/den/README
   Что это за свойства?
   Первый символ выведенной строки, в данном случае дефис, обозначает тип файла. Другие значения этого свойства: d — каталог, b — блочное устройство, с — символьное устройство, l — символическая ссылка, p — именованный канал и s — гнездо.
   Следующие 9 символов означают права доступа к файлу. Они делятся на три тройки, обозначающие права: владельца, членов его группы и всех остальных. Внутри каждой тройки может присутствовать или отсутствовать: право чтения (r), записи (w) и исполнения (x, отexecute).Отсутствие права обозначается символом дефиса. С файлом README из нашего примера владелец (в общем случае, пользователь, создавший его) имеет право делать все, что угодно; члены его группы — только читать и запускать файл на выполнение; все остальные — только читать.
   О следующем свойстве, количестве ссылок на файл, будет сказано в параграфе о символических ссылках.
   Далее указаны имя владельца файла и имя его группы; размер файла в байтах; дата и время последней модификации и имя файла.
   Для каталога вывод командыlsвыглядит так же, но значение некоторых свойств отличается.
   $ls -l -a /home/den
   drwx------ 3 den users 4096 Feb 14 19:02 .
   drwxr-xr-x 4 root root 4096 Feb 02 11:32 ..
   [...]
   Ключ -а нужен, чтобы увидеть псевдоподкаталоги «.» и «..» (их имена начинаются с точки, поэтому эти файлы скрыты).
   Бит чтения в правах доступа означает право просматривать содержание каталога, записи — право создавать и удалять файлы в каталоге, исполнения — право переходитьв этот каталог (делать его своим текущим каталогом).Файлы физических устройств
   Все подключенные к компьютеру устройства понимаются операционной системой как файлы: вывод информации на терминал, печать на принтере, отправка почты — все это, сточки зрения ОС, есть запись в файл. Технически файл устройства — это коммуникационный интерфейс драйвера, ведающего взаимодействием с этим устройством. Большинство таких файлов располагается в каталоге/dev.
   Загляните в этот каталог, введя командуls -l /dev.Вывод этой команды займет несколько экранов, что создает повод для знакомства с командой-фильтром more, выводящей поступающие к ней на вход данные по одному экрану за раз:
   $ ls -l /dev | more
   Чтобы увидеть следующий экран, нажмите пробел; чтобы прервать работу команды — Ctrl+С. О символе вертикальной черты, разделяющей командыlsиmore,подробнее сказано в п. 3.3.1.
   Об именах устройств, соответствующих разделам жесткого диска, сказано в главе 1. В следующей таблице приведена краткая справка по именам других часто используемыхустройств. Символ N означает номер устройства в группе однотипных с ним устройств.

   Наиболее часто используемые стандартные имена устройств Таблица 2.2ФайлУстройствоnullПустое устройство. Все данные, выводимые в него, просто исчезают. Удобно использовать его для вывода ненужных сообщенийconsoleСистемная консоль, т.е. физически подключенные клавиатура и мониторttyNПользовательская (виртуальная) консоль. Linux поддерживает до 6 таких консолей, для переключения между которыми служит комбинация клавиш Alt+Fn, где n — число от 1 до 6pts/NВиртуальный терминал. Программа графического режима, в окне которой можно работать как в консолиmouseNМышьaudioNЗвуковая картаttySNПоследовательный порт. Файл /dev/ttyS0 соответствует порту COM1 в MS-DOS. /dev/ttyS1 — порту COM2lpNПараллельный портcuaNСпециальное устройство для работы с модемомethNСетевая платаfdNДисковод для гибких дисков. Первому, то есть А:, соответствует /dev/fd0, для В: используется имя /dev/fd1hdxNЖесткий диск с интерфейсом IDE, где x — буква, обозначающая номер такого диска (начиная с а), N — номер раздела на дискеsdxNЖесткий диск с интерфейсом SCSI
   Вместо размера файла командаlsвыдает два числа. Это так называемые старший и младший номера устройства. Старший номер несет информацию о драйвере, к которому относится данный файл, а младший номер указывает, к какому именно из однотипных устройств следует обращаться.Жесткие и символические ссылки
   Жесткая ссылка является просто другим именем для исходного файла. После создания такой ссылки ее невозможно отличить от исходного имени файла. «Настоящего» имениу файла нет, точнее, все такие имена будут настоящими. Командаlsпоказывает количество именно таких жестких ссылок. Удаление файла по любому из его имен уменьшает на единицу количество ссылок, и окончательно файл будет удален только тогда, когда это количество станет равным нулю. Поэтому удобно использовать жесткие ссылки для того, чтобы предотвратить случайное удаление важного файла.
   Создадим жесткую ссылку на файл README и посмотрим, что изменилось в его свойствах:
   $ln /home/den/README /home/den/readme_too
   $ls -l /home/den/README
   -rwxr-xr-- 2 den users 0 Feb 14 19:08 /home/den/README
   Жесткую ссылку можно создавать в любом каталоге, но обязательно на том же физическом носителе (то есть в той же файловой системе), что и исходный файл. О причине этого будет сказано в п. 2.2.1.
   Другой тип ссылок представляют собой символические ссылки. По назначению они аналогичны ярлыкам в ОС Windows: указывают на файл, расположенный где угодно (например, на съемном носителе), и после удаления такого файла или размонтирования съемного носителя становятся бесполезны.
   Символическая ссылка создается той же командойlnс ключом-s:
   $ln -s /home/den/README /home/den/do.not.readme
   $ls -l /home/den/do.not.readme
   lrwxrwxrwx 1 den users 16 Feb 14 19:17 /home/den/do.not.readme -&gt; /home/den/README
   В поле имени файла после стрелки указано его настоящее имя. Права доступа у всех символических ссылок одинаковы и не значат ничего: возможность доступа к файлу определяется правами исходного файла. Заметьте, что в отличие от файла-оригинала файл-ссылка имеет ненулевую длину: в нем хранится абсолютное имя исходного файла. Попытайтесь вывести файл-ссылку на экран с помощью командыcat,и вы увидите содержание исходного, пустого, файла:
   $ cat /home/den/do.not.readme
   $
   Значение самой ссылки, то есть имя файла, на который она ссылается, можно узнать с помощью командыreadlink.
   Символические ссылки на каталог создаются и выглядят точно так же, как символические ссылки на обычный файл. Можно создать и цепочку ссылок на ссылки: ядро ОС проследует по всей цепочке и в итоге подставит вместо ссылки имя исходного файла.
   Можно даже закольцевать такую цепочку:
   $ touch a1
   $ ln -s a1 a2; rm a1
   $ ln -s a2 a1
   $ ls -l a? #это шаблон имени. Ему соответствуют все имена из двух букв, первая «а»
   a1 -&gt; a2
   a2 -&gt; a1
   $ cat a1
   cat: a1: Too many levels of symbolic links
   Практический смысл этого упражнения — убедить вас в том, что Linux корректно справляется с разрешением ссылок даже в намеренно некорректной ситуации.
   Символическая ссылка на каталог может участвовать в образовании полного имени файла, но есть одна тонкость: по ссылке нельзя проследовать обратно в направлении корня дерева каталогов. Вместо псевдоподкаталога «..» подставляется родительский каталог каталога-оригинала. Так, если в домашнем каталоге пользователя ivan есть ссылка на домашний каталог пользователя den, то путь /home/ivan/link_to_den_home/.. эквивалентен не /home/ivan, a /home/den/.., то есть /home.Именованные каналы
   Этот тип файла еще называется буфером FIFO (First In — First Out). Через файлы такого типа два независимых процесса (две работающих программы) могут обмениваться данными: все, что записано в файл одним процессом, может быть прочитано оттуда другим. Именованный канал создается командойmkfifo.Гнезда
   Механизм гнезд (сокетов, sockets) впервые появился в версии 4.3 BSD UNIX (ветвь UNIX, начавшая развиваться в калифорнийском университете Беркли). Позже он превратился в одну из самых популярных систем сетевого обмена сообщениями, реализованную во многих, не только UNIX-подобных, операционных системах. В честь создателей этот механизм до сих пор называют Berkeley Sockets.
   Собственно гнездо — это абстрактная конечная точка сетевого соединения. Процесс отправляет данные в сеть, записывая их в файл гнезда. При этом процессы, установившие связь через пару гнезд, могут быть запущены как на разных компьютерах, так и на одном.
   Межпроцессный обмен через гнезда используется такими стандартными компонентами Linux, как служба учета syslog и оконная система X Window.
   2.1.4.Команды работы с файлами и каталогами
   Предварительно замечу, что командой в ОС Linux называется все, что может быть выполнено: исполняемый файл, встроенная команда текущей программы и даже формируемая находу последовательность символов. Синтаксис обычной команды:
   имя_команды [короткие_ключи] [длинные_ключи] [аргументы]
   где в квадратные скобки взяты необязательные данные. Ключи можно указывать в любом порядке, разделяя их пробелами. Аргументы тоже отделяются друг от друга пробелами.
   Имена коротких ключей, или опций, состоят из одной буквы, перед которой стоит символ «-» (дефис). У ключа может быть свой аргумент. Короткие ключи, у которых нет аргументов, можно соединять под одним дефисом: так, командаls -l -a -dэквивалентна командеls -lad.
   Имена длинных ключей — это осмысленные слова, перед которыми стоят два символа «-» (дефис). Большинство команд понимают ключи--helpи--usage,требующие вывести краткую справку об использовании команды. Необязательный ключ «--» сигнализирует об окончании списка ключей и начале аргументов.
   Справку о ключах и аргументах команды можно получить по командеman.Текущий каталог
   Текущий каталог — это каталог, от которого отсчитываются относительные пути. В каждый момент времени с каждой работающей программой, в том числе с командной оболочкой, связан единственный такой каталог. Узнать, какой каталог сейчас является текущим, можно с помощью командыpwdбез аргументов.
   Сменить текущий каталог можно командой
   cd [новый_каталог]
   Для смены текущего каталога на домашний каталог пользователя можно вместо имени нового каталога указать специальный символ~:cd ~.Разрешается переходить также в псевдоподкаталоги «.» и «..». В первом случае ничего не изменится, а во втором текущим каталогом станет родительский.Просмотр содержимого каталога
   Уже знакомая командаls [имя_каталога]выводит его содержимое на экран. Если не указывать имя каталога, команда выведет содержание текущего каталога.
   Вместо имени каталога можно указать шаблон имен файлов: например,ls my*покажет все файлы и подкаталоги, имена которых начинаются с «my».
   Подробнее об аргументах и ключах командыls (как, впрочем, и любой другой команды) можно узнать у справочной системы, набрав командуman ls.Создание и удаление файла
   Создать пустой файл можно командой
   touch&lt;имя_файла&gt;
   Вообще-то она предназначена для того, чтобы для всех заинтересованных программ (например, утилиты сборки проектаmake)файл выглядел новее, чем на самом деле: она меняет время последнего изменения файла на текущее время. Но если файла с таким именем не существует, то она его создаст.
   Текстовые файлы можно создавать, вводя текст с консоли:
   $ cat&gt; hello.world
   Привет!
   Оказывается, командуcatможно заставить не только выводить файл на консоль, но и вводить с нее. Это достигается перенаправлением ввода-вывода, о котором подробнее будет сказано в главе 8. Втаком режиме командаcatсчитает своими входными данными поток байтов, поступающий с клавиатуры, и выводит его в указанный файл. Иными словами, в файл записывается все, что вы после этой команды введете с клавиатуры. Чтобы закончить ввод, нажмите Ctrl+D.
   Если файл с указанным именем существует, то командаcatперепишет его. Чтобы вместо этого добавить данные в конец файла, перенаправьте ее вывод с помощью символов&gt;&gt;:
   $ cat&gt;&gt; hello.world
   Каталог создается командой
   mkdir&lt;имя_каталога&gt;
   Чтобы операция создания файла или подкаталога прошла успешно, вы должны иметь право записи в каталог, в котором вы его создаете.
   Удалить пустой каталог можно командой
   rmdir&lt;имя_каталога&gt;
   Удаляется файл командой
   rm&lt;имя_файла&gt;
   При этом наличие прав на запись и даже чтение этого файла не требуется: достаточно иметь право на запись в каталог, где находится этот файл. Ключи командыrm:
   ? -i:требует подтверждения удаления для каждого удаляемого файла. Если вы заказали удаление группы файлов (например, по шаблону имениrm chernovik*),то среди них может оказаться файл, который вам еще нужен: безопаснее применить ключ -i. Подтвердите удаление каждого файла или откажитесь от него, введя символ Y или N соответственно;
   ? -f:не запрашивать подтверждения, не выводить сообщений об ошибках. Если указаны оба ключа-iи-f,то срабатывает последний указанный;
   ? -r:рекурсивное удаление каталога со всеми его подкаталогами. Непустой каталог можно удалить только так.Копирование и перемещение файла
   Файл копируется командойcp.Формат этой команды:
   cp [ключи]&lt;исходный_файл&gt; {&lt;файл_назначения&gt; |&lt;каталог_назначения&gt;}
   Полезные ключи командыcp:
   ? -i:требовать подтверждения перед перезаписью существующего файла;
   ? -f:не требовать подтверждения;
   ? -r:рекурсивно копировать каталог со всеми подкаталогами;
   ? -а:сохранять атрибуты файла;
   ? -d:копировать символические ссылки вместо файлов, на которые они указывают;
   ? -s:создавать символические ссылки вместо копирования (-l — жесткие);
   ? -u:не переписывать существующий файл, если он модифицирован позже;
   ? -х:игнорировать подкаталоги, расположенные в других файловых системах.
   Кстати, командаcatс перенаправленным выводом тоже может скопировать файл:
   $ cat hello.world&gt; copy.of.hello.world
   Командаmvперемещает или переименовывает файлы. Формат команды:
   mv [ключи]&lt;исходный_файл&gt; {&lt;файл_назначения&gt; |&lt;каталог_назначения&gt;}
   Ключи -i, -f имеют тот же смысл, что для команд cp и rm.Просмотр текстовых файлов
   Перед тем, как просматривать файл, неплохо было бы убедиться, что он действительно является текстовым, то есть содержит только печатные ASCII-символы. Для проверки типа файла служит команда
   file&lt;имя_файла&gt;
   Если ее ответ содержит слово «text», то файл можно безопасно вывести на терминал. Вывод двоичного файла может сбить кодировку так, что вместо набираемых на клавиатуре символов вы увидите черт знает что. Если это все же случилось, введите вслепую команду
   $ tput reset
   (или, если вы работаете в графическом режиме в окне виртуального терминала, выберите в его меню командуТерминал|Сброс и очисткадля среды GNOME илиEdit|Reset& Clear Terminalдля среды KDE).
   Кроме уже упомянутой командыcat,для вывода файла на терминал служат команда
   more&lt;имя_файла&gt;
   и ее улучшенный вариантless.
   Команда-фильтрmoreразбивает поток своего вывода на порции размером в экран и ожидает ввода пользователя для отображения следующей порции. Чтобы увидеть следующую строку, нажмите&lt;Ввод&gt;;чтобы увидеть следующий экран, нажмите&lt;пробел&gt;;чтобы прервать работу команды, нажмите&lt;Q&gt;или Ctrl+C.
   Утилита less позволяет листать выводимый файл не только вперед, но и назад (клавишами PgDn и PgUp), перемещаться к указанному месту в файле, искать по образцу и дает еще много полезных возможностей. В общем, man less.
   Если интересующая вас информация находится в конце файла (например, вы хотите просмотреть журнал системных сообщенийmessagesв каталоге/var/log,чтобы узнать, что именно только что пошло наперекосяк), то вам поможет команда
   tail [-N] [имя_файла]
   где N — число выводимых строк файла, считая от последней. Командой
   head [-N] [имя_файла]
   можно просмотреть, наоборот, только первые N его строк. Значение N по умолчанию равно 10.
   Если вы хотите просмотреть не весь файл, а только те его строки, которые содержат заданный фрагмент текста, используйте команду-фильтрgrep.Например, я хочу сменить клавишу переключения раскладки клавиатуры в графическом режиме. Я знаю, что строки конфигурационного файла/etc/X11/xorg.conf,имеющие отношение к клавиатуре, содержат фрагмент XKB… а может, Xkb или xkb? Неважно:
   $ grep -in xkb /etc/X11/xorg.conf
   [...]
   65: Option "XkbLayout" "us,ru"
   66: Option "XkbOptions" "grp:shift_toggle,grp_led:scroll"
   Я указал ключи: -i, требующий игнорировать различия регистра в образце для поиска и файле, и -n, требующий выводить номера строк, в которых встречается образен xkb.
   Для всех команд ключи без аргументов можно соединять: запись -in эквивалентна записи -i -n.Редактирование текстовых файлов
   Вышеприведенный пример показывает, что переключением раскладки клавиатуры в графическом режиме управляет комбинация клавиш Shift + Shift. Неудобно: в консольном режиме я привык к Ctrl+Shift. Надо заменить значение shift_toggle на ctrl_shift_toggle. Такие мелкие правки конфигурационных файлов — обычное дело для администратора, поэтому средство их внесения присутствовало в UNIX-системах всегда. Это консольный редакторvi,входящий в каждый дистрибутив Linux (в дистрибутив Fedora Core 3 включен его улучшенный вариантvim,но командаviтоже доступна: она стала псевдонимом для командыvim).
   Итак, я делаю на всякий случай резервную копию конфигурационного файла/etc/X11/xorg.confи приступаю к его редактированию:
   $ cp /etc/X11/xorg.conf /etc/X11/xorg.conf.sav
   $ vi /etc/X11/xorg.conf
   Перемещаюсь к строке 66 командой66G (буква G заглавная: редакторviразличает регистры). Клавишами управления курсором перемещаюсь к началу слова shift.
   Включаю режим вставки командойi (строчная буква). Набираю ctrl_. Выключаю режим вставки клавишей Esc. Сохраняю изменения командой:w.Выхожу по команде:q.
   Сложно и на вид бессистемно? Да. Зато есть команда:help.
   Как полноэкранный редактор,viможет находиться в одном из двух режимов. В режиме вставки вводимые символы поступают в редактируемый файл, в командном режиме они воспринимаются как команды. Перечислю коротко самые употребительные команды редактораvi:
   РЕЖИМ ВСТАВКИ.
   Включение режима вставки:
   ? i в текущей позиции курсора;
   ? I перед первым непробельным символом в текущей строке;
   ? w в новой строке, добавленной после текущей;
   ? W в новой строке, добавленной перед текущей.
   Выключение режима вставки:
   ? &lt;Esc&gt;
   Команды режима вставки:
   ? Ctrl+a повторить предыдущую вставку;
   ? Ctrl+у вставить символ, находящийся над курсором (в предыдущей строке);
   ? Ctrl+e вставить символ, находящийся под курсором (в следующей строке).
   КОМАНДНЫЙ РЕЖИМ.
   Удаление (здесь и далее N — это число):
   ? N x N символов под курсором и справа от него;
   ? N X N символов слева от курсора;
   ? N dd N строк;
   ? D до конца текущей строки;
   ? N D до конца текущей строки и еще N-1 строку.
   Копирование и вставка строк:
   ? N yy взять в буфер N строк от текущей и ниже;
   ? p вставить содержимое буфера после текущей строки;
   ? P вставить содержимое буфера перед текущей строкой.
   Поиск и переход:
   ? N G перейти к строке с номером N;
   ? $ G перейти к последней строке файла;
   ? /&lt;образец&gt;искать образец вниз от курсора;
   ? ?&lt;образец&gt;искать образец вверх от курсора;
   ? n повторить поиск в том же направлении;
   ? N (буквально «N»): повторить поиск в обратном направлении.
   Сохранение и выход:
   ? :w сохранить текущий файл;
   ? :w&lt;имя&gt;сохранить под новым именем, если файл&lt;имя&gt;еще не существует;
   ? :w!&lt;имя&gt;сохранить пол новым именем, переписав существующий файл;
   ? :q выйти;
   ? :q! принудительно выйти без сохранения;
   ? :wq сохранить и выйти.
   Разное полезное:
   ? N u отменить последние N изменений;
   ? N Ctrl+r вернуть последние N отмененных изменений;
   ? U отменить изменения в последней строке;
   ? N r&lt;символ&gt;заменить N следующих символов на&lt;символ&gt;;
   ? N&gt;&gt;добавить отступ (Tab) в N следующих строк;
   ? N&lt;&lt;удалить один отступ (Tab) из N следующих строк;
   ? :sh временно выйти в оболочку (вернуться — exit);
   ? :!&lt;команда&gt;выполнить команду оболочки.Поиск файлов
   Быстрый поиск имени программы можно выполнить прямо из командной строки: для этого введите первые буквы нужной вам команды и нажмите&lt;Tab&gt;.Если введенные вами буквы однозначно определяют команду или исполняемый файл, то ее имя появится в командной строке. Эта функция называетсяавтозаполнением командной строки.Если не появилось ничего, нажмите&lt;Tab&gt;еще раз для вывода списка всех доступных команд, начинающихся со введенных букв. Если таких команд окажется больше сотни, у вас попросят подтверждения того, что вы действительно хотите увидеть их все.
   В разных каталогах может оказаться несколько исполняемых файлов с одинаковыми именами. Какой из них будет исполнен? На этот вопрос отвечает командаwhich.Она просматривает каталоги, перечисленные в переменной окружения PATH, в поисках исполняемого файла с указанным именем, и выводит абсолютное имя первого встреченного из них.
   Командаwhereisищет не только исполняемый файл, но и его справочные страницы и исходный код.
   Командаlocateищет файл по образцу имени, опираясь на свою базу данных о файловой системе. Ее вариант с повышенной безопасностьюslocateсохраняет данные о правах доступа к файлам, так что пользователь не увидит тех файлов, на которые у него нет прав. В дистрибутиве Fedora Core 3 командаlocateпредставляет собой символическую ссылку на утилитуslocate.
   Командаfindищет файл по его атрибутам в указанном каталоге и его подкаталогах на заданную глубину. Например, при установке операционной системы я отказался устанавливать файловый менеджер Midnight Commander, а теперь он мне понадобился. Для каждого из 4 компакт- дисков дистрибутива запускаю команду поиска по шаблону имени «mc*», то есть всех файлов, имена которых начинаются с mc:
   $find /media -name mc*
   /media/cdrecorder/Fedora/RPMS/mc-4.6.1-0.8.i386.rpm
   В итоге на третьем диске найден пакет RPM. Об установке программного обеспечения из пакетов RPM будет сказано в главе 7.Изменение прав доступа к файлу
   Как многопользовательская операционная система, ОС Linux содержит механизм разграничения доступа к данным, позволяющий как защитить данные одного пользователя от нежелательного вмешательства других, так и разрешить другим доступ к этим данным для совместной работы.
   Как уже сказано, любой ресурс компьютера под управлением ОС Linux представляется как файл, поэтому мы будем говорить только о правах доступа к файлу.
   По отношению к файлу пользователь может входить в одну из трех категорий: владелец, член группы владельца, все остальные. Для каждой из этих категорий есть свой набор прав доступа.
   Первым владельцем файла становится его создатель. Дальше файл можно передать другому владельцу или в другую группу командой
   chown [ключи]&lt;новый_пользователь&gt;[:новая_группа]&lt;файл&gt;
   или
   chgrp [ключи]&lt;новая_группа&gt;&lt;файл&gt;
   В некоторых реализациях Linux передать файл другому владельцу имеет право только суперпользователь, а в других — также его текущий владелец.
   Набор прав доступа состоит из прав на чтение, запись и исполнение файла. В символьном представлении он выглядит как строка «rwx», где вместо любого символа может стоять дефис. Буква означает наличие права (r — чтение, w — запись, x — исполнение), дефис — его отсутствие.
   Очевидно, что эти три бита могут быть записаны еще и как восьмеричное число. Так, права доступа r-x (чтение и исполнение без записи) понимаются как три двоичные цифры 101 или как восьмеричная цифра 5. Численное представление прав доступа называется абсолютным, или двоичной маской.
   Полная строка прав доступа в символьном представлении устроена так:
   &lt;права_владельца&gt;&lt;права_группы&gt;&lt;права_остальных&gt;
   В абсолютном представлении права владельца являются старшим разрядом восьмеричного числа, права группы — вторым и права остальных — третьим. Так, права rwxr-x--x выглядят как число 111 101 001, или 751.
   Команда изменения прав доступаchmodпонимает как абсолютное, так и символьное указание прав.
   Назначим файлу/home/den/READMEправа rw-r-----, то есть разрешим себе чтение и запись, группе только чтение, остальным пользователям — ничего:
   $cd ~ #переход в свой домашний каталог
   $chmod 640 README # 110 100 000 == 640
   $ls -l README
   -rw-r----- 1 den users 0 Feb 14 19:08 /home/den/README
   В символьном представлении можно явно указывать, кому какое право мы хотим добавить, отнять или присвоить. Добавим право на исполнение файла README группе и всем остальным:
   $chmod go+x README
   $ls -l README
   -rw-r-x--x 1 den users 0 Feb 14 19:08 /home/den/README
   Формат символьного режима:
   chmod&lt;категория&gt;&lt;действие&gt;&lt;набор_прав&gt;&lt;файл&gt;
   Возможные значения аргументов команды представлены в таблице 2.3.

   Аргументы командыchmodв символьном режиме Таблица 2.3АргументЗначениеКатегорияuВладелецgГруппа владельцаoПрочиеaВсе пользователи, то есть «a» эквивалентно «ugo»Действие+Добавить набор прав-Отменить набор прав=Назначить набор правПравоrПраво на чтениеwПраво на записьxПраво на исполнениеsПраво смены идентификатора пользователя или группыtБит прилипчивости (sticky-бит)uТакие же права, как у владельцаgТакие же права, как у группыoТакие же права, как у прочих
   Название бита прилипчивости унаследовано от тех времен, когда объем оперативной памяти был маленьким, а процесс подкачки медленным. Этот бит позволял оставлять небольшие часто используемые программы в памяти для ускорения их запуска. Сейчас его значение переосмыслено: этот бит, установленный для каталога, приводит к тому, что удалять файлы из этого каталога могут только владелец файла и владелец каталога. Обычно это используется в каталогах, открытых для записи всем (например,/tmp).
   Права смены пользователя и группы (SUlD-бит и SGID-бит) означают следующее. Обычно исполняемый файл (программа или командный сценарий) получает те же права на доступ к файлам, что и пользователь, который запустил его на выполнение. Но у этого файла есть еще и владелец, полномочия которого могут быть совсем другими. Наличие одного из этих битов позволяет выполняющейся программе пользоваться полномочиями владельца программного файла или члена его группы
   Так, командаsu (substitute user),позволяющая «стать» другим пользователем без завершения своего сеанса и входа под новым именем (это нужно, например, чтобы быстро выполнить административную задачу от имени суперпользователя), имеет следующие атрибуты:
   $ls -l `which su`
   -rwsr-xr-x 1 root root [размер, дата, время] /bin/su
   Биты «x» сообщают, что любой пользователь может запустить эту программу, а бит «s» — о том, что во время ее выполнения он будет пользоваться правами суперпользователя root (если, конечно, знает пароль).
   Обратите внимание на применение обратных апострофов: они нужны для того, чтобы направить вывод командыwhichна вход командыls.
   Следует учитывать, что программы, требующие установления SUID (или SGID) для своей работы, являются потенциальными дырами в системе безопасности. Представьте такую ситуацию: у вас в системе установлена программаsuperformat,которая предназначена для форматирования дисков. Создание файловой системы, пусть даже на дискете, — это привилегированная операция, требующая полномочий суперпользователя.
   При установке этой программы для нее сразу устанавливается право SUID, чтобы разрешить пользователям форматировать дискеты. Пользователь запускает ее для форматирования дискеты. Программа запускается, получает права root, форматирует дискету и нормально завершает работу.
   А если она завершает работу аварийно, например, по ошибке переполнения стека (такие случаи отмечались)? Тогда запустивший ее пользователь получит права root! Неквалифицированный пользователь с правами root — это намного хуже, чем просто крах системы. Помните о потенциальной опасности при работе с такими программами и по возможности избегайте использования прав SUID и SGID.
   Справедливости ради нужно заметить, что ряд системных программ (в частности, демон установления интернет-соединенияpppd)разрабатывался с учетом прав SUID и SGID, и эти программы являются максимально защищенными, хотя полной уверенности в этом нет. Поэтому использовать право SUID нужно только в самых крайних случаях.
   Я позволю себе сделать еще несколько замечаний относительно прав доступа SUID и SGID:
   1. Лучше не использовать программы, требующие привилегий, на сервере, точнее, не разрешать обыкновенным пользователям их использовать. Использование права доступа SUID вы можете себе позволить только на своей домашней машине, например, для установления того же коммутируемого соединения, чтобы каждый раз при подключении к Интернету не вводить команду su.
   2. Перед использованием программ, требующих привилегии root, убедитесь в их надежности. Если программа получена из ненадежного источника, лучше ее не использовать. Надежными источниками считаются сайты или FTP-серверы разработчиков дистрибутивов Linux, Желательно получить исходный код такой программы, чтобы убедиться, что она не производит каких-либо несанкционированных действий.
   3. Нет ни одной причины, по какой нужно было бы разрешить использование SUlD-программ в домашних каталогах пользователей. Для разделов, в которые разрешена запись обыкновенным пользователям, установите опцию nosuid в файле/etc/fstab.
   2.2.Изнанка файловой системы
   С точки зрения операционной системы, под файловой системой понимается внутренняя управляющая структура, заведующая хранением данных на физическом носителе, их поиском, извлечением и записью по запросам программ. Такие управляющие структуры в каждом семействе операционных систем строятся по схожим принципам. Так, DOS/Windows используют файловую систему FAT с вариантами FAT32 и VFAT. Файловые системы UNIX-подобных ОС разнообразнее, но тоже могут быть объединены в одно семейство. Linux умеет работать со множеством файловых систем, как с родными, и с еще большим их количеством обмениваться данными.Примечание
   Хотя существуют средства установки Linux в раздел FAT/FAT32 —Lin4Win,я не рекомендую их использовать, т.к. в этом случае Linux работает крайне нестабильно и медленно.
   Типичным представителем файловых систем UNIX является «вторая расширенная файловая система» ext2fs, основная до недавнего времени файловая система Linux. С момента выхода ядра версии 2.4.16 она начала уступать место «файловой системы по умолчанию» полностью совместимой с ней системе ext3fs. Рекомендуется использовать именно ext3fs, и именно она устанавливается по умолчанию инсталляторами большинства современных дистрибутивов.
   2.2.1.Файловая система ext2fs — предшественница ext3fs
   Рассмотрим логическую структуру файловой системы ext2fs.
   Физически жесткий диск разбит на сектора размером 512 байт. Первый сектор дискового раздела в любой файловой системе считается загрузочной областью. В первичном разделе эта область содержит загрузочную запись — фрагмент кода, который инициирует процесс загрузки операционной системы при запуске. На других разделах эта область не используется. Остальные сектора объединены в логические блоки размером 1, 2 или 4 килобайта. Логический блок есть наименьшая адресуемая порция данных: данные каждого файла занимают целое число блоков. Блоки, в свою очередь, объединяются в группы блоков. Группы блоков и блоки внутри группы нумеруются последовательно, начиная с 1.
   Раздел диска, на котором сформирована файловая система ext2fs, может быть представлен такой схемой:
   Структуры данных, применяемые при работе с файловой системой ext2fs, описаны в заголовочном файле/usr/include/linux/ext2fs.h.
   Суперблок служит начальной точкой файловой системы и хранит всю информацию о ней. Он имеет размер 1024 байта и располагается по смещению 1024 байта от начала файловой системы. В каждой группе блоков он дублируется, что позволяет быстро восстановить его после сбоев.
   В суперблоке определяется размер файловой системы, максимальное число файлов в разделе, объем свободного пространства и содержится информация о том, где искать незанятые участки. При запуске ОС суперблок считывается в память и все изменения файловой системы вначале находят отображение в копии суперблока, находящейся в ОП, и записываются на диск только периодически. Это позволяет повысить производительность системы, так как многие пользователи и процессы постоянно обновляют файлы. Сдругой стороны, при останове системы суперблок обязательно должен быть записан на диск, что не позволяет выключать компьютер простым выключением питания. В противном случае, при следующей загрузке информация, записанная в суперблоке, окажется не соответствующей реальному состоянию файловой системы. [Картинка: img_29.jpeg] 
   Рис. 2.1.Структура файловой системы
   После суперблока следует описание (дескриптор) группы блоков. Хранящаяся в нем информация позволяет найти битовые карты блоков и индексных дескрипторов, а также таблицу индексных дескрипторов.
   Битовой картой блоков (block bitmap) называется структура, каждый бит которой показывает, отведен ли такой же по счету блок какому-либо файлу. Значение 1 показывает, что блок занят. Эта карта служит для поиска свободных блоков в тех случаях, когда надо выделить место под файл.
   Битовая карта индексных дескрипторов выполняет аналогичную функцию по отношению к таблице индексных дескрипторов: показывает, какие именно дескрипторы заняты.
   Каждому файлу соответствует один и только один индексный дескриптор (inode, i-узел, информационный узел), который идентифицируется своим порядковым номером — индексом файла. В индексном дескрипторе хранятся метаданные файла. Среди них — все атрибуты файла, кроме его имени, и указатель на данные файла.
   Для обычного файла или каталога этот указатель представляет собой массив из 15 адресов блоков. Первые 12 адресов в этом массиве являются прямыми ссылками на номера блоков, в которых хранятся данные файла. Если данные не помещаются в 12 блоков, то включается механизм косвенной адресации. Следующий адрес в этом массиве является косвенной ссылкой, то есть адресом блока, в котором хранится список адресов следующих блоков с данными из этого файла.
   Сколько блоков с данными можно так адресовать? Адрес блока занимает 4 байта, блок, как уже сказано, — 1, 2 или 4 килобайта. Значит, путем косвенной адресации можно разместить 256 — 1024 блока. Размер файла, занимающего столько блоков, считайте сами.
   А если файл еще длиннее? Следующий адрес в массиве-указателе указывает на блок двойной косвенной адресации (double indirect block).Этот блок содержит список адресов блоков, которые, в свою очередь, содержат списки адресов следующих блоков данных.
   И, наконец, последний адрес в массиве-указателе задает адрес блока тройной косвенной адресации, то есть блока со списком адресов блоков, которые являются блоками двойной косвенной адресации.
   Пока остается непонятным, где находится имя файла, если его нет ни среди данных файла, ни среди его метаданных, В UNIX-подобных системах имя файла есть атрибут не самого файла, а файловой системы, понимаемой как логическая структура каталогов. Имя файла хранится только в каталоге, к которому файл приписан, и больше нигде. Из этого вытекают любопытные следствия.
   Во-первых, одному индексному дескриптору может соответствовать любое количество имен, приписанных к разным каталогам, и все они являются настоящими. Количество имен (жестких ссылок) учитывается в индексном дескрипторе. Именно это количество вы можете увидеть по команде ls -l.
   Во-вторых, удаление файла означает просто удаление записи о нем из данных каталога и уменьшение на 1 счетчика ссылок.
   В-третьих, сопоставить имя можно только номеру индексного дескриптора внутри одной и той же файловой системы, именно поэтому нельзя создать жесткую ссылку в другую файловую систему (символическую — можно, у нее другой механизм хранения).
   Сам каталог таким же образом приписан к своему родительскому каталогу. Корневой каталог всегда записан в индексный дескриптор с номером 2 (номер 1 отведен для списка адресов дефектных блоков). В каждом каталоге хранится ссылка на него самого и на его родительский каталог — это и есть псевдоподкаталоги «.» и «..».
   Таким образом, количество ссылок на каталог равно количеству его подкаталогов плюс два.
   Данные каталога представляют собой связный список с записями переменной длины и выглядят примерно так, как на рис. 2.2. [Картинка: img_30.jpeg] 
   Рис. 2.2.Строение каталога в ext2fs
   А как же файлы физических устройств? Они могут находиться в тех же каталогах, что и обычные файлы: в каталоге нет никаких данных, говорящих о принадлежности имени файлу на диске или устройству. Разница находится на уровне индексного дескриптора. Если i-узел обычного файла указывает на дисковые блоки, где хранятся его данные, тов i-узле файла устройства содержится указатель на список драйверов устройств в ядре — тот элемент списка, который соответствует старшему номеру устройства (рис. 2.3). [Картинка: img_31.jpeg] 
   Рис. 2.3.Разница между обычным файлом и файлом устройства
   Свойства файловой системы ext2fs:
   ? Максимальный размер файловой системы — 4 Тбайт.
   ? Максимальный размер файла — 2 Гбайт.
   ? Максимальная длина имени файла — 255 символов.
   ? Минимальный размер блока — 1024 байт.
   ? Количество выделяемых индексных дескрипторов — 1 на 4096 байт раздела.
   2.2.2.Журналируемые файловые системы
   Представим такую ситуацию. У вас есть жесткий диск, скажем, на 80 Гб. Сегодня таким объемом никого не удивишь, не так ли? Вы поленились разбить его на разделы, и у вас есть один большой раздел, занимающий все ваши 80 Гб. И вот в момент записи на диск произошло отключение питания. Хорошо, если это случилось во время записи данных какого-то файла, пусть и очень важного: файл можно восстановить хотя бы частично. А вот если свет погас, когда операционная система записывала метаданные, то расположениефайла на диске перестанет соответствовать списку принадлежащих ему блоков в индексном дескрипторе. Файловая система может утратить целостность, то есть такое состояние, когда каждый блок принадлежит не более чем одному файлу (inode).В результате вы можете не досчитаться не одного, а сотни файлов.
   Признаком потери целостности служит бит чистого размонтирования (clean bit),точнее, его отсутствие. Этот бит сбрасывается при подключении (монтировании) файловой системы в знак того, что файловая система сейчас используется. После успешного размонтирования файловой системы этот бит устанавливается снова.
   Если при монтировании файловой системы в процессе загрузки операционная система обнаруживает, что чистый бит не установлен, она запускает средство проверки файловой системы — программуfsck.Представляете, сколько времени займет такая проверка? Даже при условии, что ошибок будет мало или вообще не будет, придется ждать довольно долго. А если еще будет нарушена целостность, тогда восстановление этой целостности займет еще несколько минут вашего времени.
   Все это справедливо для обычной файловой системы. Журналируемая же файловая система перед тем, как что-то сделать с файлами, записывает на диск некое описание планируемой операции и вычеркивает каждый пункт плана только после того, как он успешно выполнен. Тогда после сбоя можно будет не проверять на целостность весь огромный раздел, а только просмотреть журнал и откатить незаконченные операции.
   Имейте в виду, что целью журналирования является обеспечение целостности файловой системы, а не сохранность пользовательских данных как таковых.
   Журналировать операции записи самих данных тоже можно: в этом случае есть вероятность, что данные после сбоя будут восстановлены. Правда, согласно золотому правилу механики, за все нужно платить, и платить приходится быстродействием.
   Решают вопрос разными ухищрениями: например, запись происходит в момент наименьшей активности, некоторые журналируемые файловые системы позволяют разместить журнал на другом физическом диске. Да и фактически время работы с журналом намного меньше, чем работа непосредственно с данными. И, естественно, некоторый полезный объем теперь приходится отводить под сам журнал, но его размеры обычно не превышают 32 Мбайт, что по нынешним временам не так уж и много.
   И все же лучшим средством от неожиданного отключения до сих пор являются источники бесперебойного питания…
   Современные версии ядра Linux (2.6.x) поддерживают в качестве родных четыре журналируемые файловые системы: ReiserFS, ext3fs, XFS и JFS. Из них журналирование данных поддерживает только ext3fs. Список файловых систем, которые поддерживаются вашим ядром, содержится в файле/proc/filesystems.ReiserFS
   Разработана Хансом Райзером (Hans Reiser) и его компанией Namesys (http://www.namesys.com)и официально включена в ядро 2.4.4. Преимущества данной ФС в основном проявляются в работе с мелкими файлами: они целиком хранятся в своих i-узлах (inode),без выделения блоков в области данных. Вместе с экономией места это способствует и росту производительности, так как данные и метаданные хранятся в непосредственной близости и могут быть считаны одной операцией ввода/вывода.
   Другая особенность ReiserFS состоит в том, что хвосты файлов длиной меньше чем в один блок могут быть упакованы в один дисковый блок (режим тайлинга). Это обеспечивает около 5% экономии дискового пространства. Именно работа с маленькими файлами (меньше килобайта) и обслуживание большого их количества выделяет данную ФС среди прочих.
   ReiserFSнесовместима с ext2fs на уровне утилит обслуживания файловой системы, однако соответствующий инструментарий, объединенный в пакет reiserfsprogs, уже давно включается в стандартную поставку современных дистрибутивов. Если у вас его нет, то скачать можно по адресуftp://ftp.namesys.com/pub/reiserfsprogs/reiserfsprogs-3.6.19.tar.gz.
   Там же можно взять патчи для ядра 2.4.x.
   К сожалению, загрузчики Linux (LILO и GRUB) не способны загрузить ядро Linux с раздела ReiserFS, оптимизированного в режиме тайлинга. Поэтому под каталог /boot лучше отводить отдельный раздел с файловой системой, совместимой с ext2fs.XFS
   При работе с огромными (терабайтными) файлами вне конкуренции остается файловая система XFS, разработанная компанией Silicon Graphics (сейчас SGI) специально для операций с мультимедийными данными и впервые появившаяся в 1994 г. в версии ОС Irix 5.3. Она использует 64-битную адресацию, что позволяет увеличить максимальный размер файловой системы до 18 тысяч петабайт (при этом предельный размер файла составляет 9 тысяч петабайт).
   Особенностью этой файловой системы является устройство журнала: в журнал пишется часть метаданных самой файловой системы таким образом, что весь процесс восстановления после сбоя сводится к копированию этих данных из журнала в файловую систему. Размер журнала задается при создании системы, он должен быть не меньше 32 мегабайт.
   XFSэффективно распараллеливает операции ввода-вывода: она делит все пространство раздела на несколько равных областей (allocation group),служащих своего рода автономными файловыми системами в рамках единой XFS.
   Пакет утилит обслуживания xfsprogs можно скачать сhttp://oss.sgi.com/projects/xfs/download.html (содержит ссылку на российское зеркало).JFS
   Разработана IBM для рабочих станций под управлением ОС AIX, затем портирована для Linux и выпущена по Стандартной Общественной Лицензии. Всю необходимую информацию о ней можно найти по адресуhttp://jfs.sourceforge.net.
   Размер журнала составляет примерно 40% от размера файловой системы. Эта файловая система может содержать несколько сегментов, содержащих журнал и данные. Такие сегменты называются агрегатами и могут монтироваться отдельно. Умеет она также хранить маленькие файлы и каталог и, содержащие не больше 8 файлов, в пределах индексного дескриптора.
   Широкого признания пока не получила.Ext3fs
   Файловая система ext3fs официально включена в ядро Linux с версии 2.4.16. Впервые она появилась в дистрибутивах RedHat и SuSE. Современные дистрибутивы, основанные на ядре 2.6.x, предлагают установить ext3fs по умолчанию.
   Некоторые источники утверждают, что ext3fs — это всего лишь «надстройка» над файловой системой ext2fs, а не самостоятельная файловая система. Благодаря такому происхождению ext3fs совместима со всеми программами для обслуживания и настройки файловой системы ext2fs. И перейти на ext3fs можно простым добавлением файла журнала к ext2fs, не только без переформатирования раздела, но даже и без перезагрузки машины. Более того, ОС Linux на старых ядрах, не поддерживающих ext3fs, могут работать с разделами, на которых сформирована эта файловая система, просто подключая их как разделы ext2fs.
   Кроме того, ext3fs — самая надежная из рассмотренных в этом параграфе новых файловых систем: в ней предусмотрено журналирование операций не только с метаданными, но и с данными файлов.
   Журнал может быть включен в одном из следующих режимов:
   ? полного журналирования (journal);
   ? последовательном (ordered, применяется по умолчанию);
   ? обратной записи (writeback).
   Режим полного журналирования позволяет минимизировать ваши потери при отключении питания, но является наиболее медленным из всех трех режимов. Этот режим и подразумевает журналирование записи пользовательских данных.
   Самый быстрый режим — это «обратная запись». Это обыкновенное журналирование только метаданных.
   Режим «последовательный» представляет собой компромисс между скоростью и полнотой. Официально журналируются только метаданные, но блоки соответствующих им данных записываются первыми. В большинстве случаев такой режим гарантирует сохранность данных, особенно если данные дописывались в конец файла, как обычно и бывает.
   Какой режим выбрать? Если ваш сервер является файловым (FTP, WWW-сервер), то есть таким, который используется пользователями для хранения файлов, выберите режим полного журналирования — пользователи будут вам благодарны. Пусть в этом режиме сервер будет работать чуть медленнее, зато в случае ЧП можно минимизировать потери информации. Во всех остальных случаях нужно установить режим «Последовательный», точнее вообще не нужно ничего устанавливать — он используется по умолчанию.
   2.3.Создание и монтирование файловых системСоздание файловой системы «вручную». Команда mkfs
   Из предыдущего параграфа следует, что создать файловую систему на разделе жесткого диска или внешнем носителе — это значит разметить его сектора на структуры данных, специфические для этой файловой системы (суперблок, список i-узлов, блоки данных). В DOS/Windows этот процесс называется форматированием. В UNIX-системах понятие форматирования не используется, а процедура и соответствующая команда так и называются — создание файловой системы.
   В ходе установки Linux файловые системы на разделах жесткого диска создал для вас инсталлятор, и переделывать за ним ничего не нужно. Ручное создание ФС может понадобиться при подключении нового диска или, что гораздо чаще, дискеты. Выполняет его командаmkfs:
   mkfs [-t&lt;тип&gt;] [опции_ФС] ФС [блоков]
   Типыи описание файловых систем, поддерживаемых Linux, вы найдете в справочной системе по командеman fs.Те типы, которые чаще всего используются на съемных носителях, перечислены в таблице 4.3. Ясно, что если вы «отформатируете» дискету с типомvfat,то она будет читаться и из-под Windows, а если с типом ext2/ext3 — только из-под Linux.
   Если не указывать тип, то будет создана ФС с типом по умолчанию — в настоящий момент это ext2.
   В качестве аргумента ФС можно указывать либо имя устройства (/dev/fd0),либо точку монтирования (/media/usbdisk).Последним аргументом можно указать количество блоков, которые нужно отвести под новую файловую систему.
   Опции_ФС— это параметры, специфические для файловой системы определенного типа. Например, для ext2/ext3 можно указать:
   ? -b&lt;размер_блока&gt; (по умолчанию 4096 байт, но может быть и 1024 или 2048);
   ? -N&lt;количество_i-узлов&gt;,
   ? -i&lt;байт_на_i-узел&gt;.
   Утилитаmkfsпередает эти опции настоящему конструктору ФС, которого вызывает в зависимости от указанного типа. Установленные у вас конструкторы можно найти по командеls /sbin/mkfs*,а список опций конкретной ФС посмотреть на man-странице соответствующего конструктора (например,man mkfs.vfat).
   Замечу только, что для ext3fs после ключа-Jможно указать опции журналирования:size=&lt;размер&gt;— размер журнального файла в мегабайтах, иdevice=&lt;устройство&gt;— внешний журнал, заранее созданный на другом разделе.
   Как я уже сказал, преобразовать существующий раздел ext2fs в ext3fs можно без перезагрузки системы, простым добавлением журнала командойtune2fs:
   # tune2fs -j /dev/hd5
   Дополнительные конструкторы (для ReiserFS, XFS и т.п.) устанавливаются из пакетовreiserfsprogsиxfsprogsсоответственно.
   В результате на новом разделе образуется корневой каталог новой файловой системы и в нем — подкаталог/lost+found.Не удаляйте этот подкаталог: утилитаfsck,предназначенная для проверки целостности ФС, помещает в него найденные куски нарушенных файлов.Настройка автоматического монтирования при загрузке компьютера. Команда mount
   Чтобы с новой файловой системой можно было работать, она должна быть при помощи операции монтирования включена в общее дерево каталогов (п.1.1.3). О ручном монтировании/размонтировании применительно к съемным носителям сказано в п.4.2.5, а здесь я скажу, как сделать так, чтобы разделы жесткого диска автоматически монтировались призагрузке системы и демонтировались при останове. Для этого их нужно прописать в файл/etc/fstab,который читает командаmountв ходе начальной загрузки (об этапах загрузки и загрузочных сценариях см. п.9.1).
   Каждая строка этого файла соответствует одной файловой системе и состоит из шести полей, разделенных пробельными символами:
   &lt;устройство&gt;&lt;точка_монтирования&gt;&lt;тип&gt;&lt;опции&gt;&lt;дамп&gt;&lt;номер_fsck&gt;
   ? Устройство— это файл устройства, к которому подключен раздел (например,/dev/hda5).Для сетевой файловой системы здесь должно быть указано имя сервера и каталог на нем.
   ? Точка_монтирования— это имя каталога, к которому файловая система будет подключена. Он должен существовать и (желательно) быть пустым. Для раздела подкачки (swap) значение этого поля не используется, но в файле/etc/fstabприсутствовать все равно должно.
   ? Вместотипа ФСможно указать значение auto: в этом случае командаmountпопытается определить тип самостоятельно.
   ? Дамп— это отметка о необходимости резервного копирования данной ФС программойdump (п.10.4.3). Значение 1 говорит о том, что резервировать нужно, значение 0 — нет.
   ? Номер_fsck:утилитаfsckобычно запускается перед автоматическим монтированием ФС, проверяет ее на целостность и пытается исправить найденные ошибки. Это процедура долгая, и для ускорения загрузки можно либо отключить проверку для некоторых ФС (значение 0), либо для некоторых разделов запускать ее параллельно. Значение этого поля задает порядок проверки разных ФС: если номера одинаковые, то системы будут проверяться параллельно. Ясно, что ускорение может получиться только в том случае, когда параллельно проверяемые разделы находятся на разных физических дисках.
   Справку об опциях монтирования командыmountможно получить по командеman mount.В таблице 2.4 перечислены самые употребительные из них.

   Основные опции монтирования Таблица 2.4ОпцияНазначениеautoФС может быть смонтирована автоматическигаСмонтировать файловую систему в режиме «только чтение»rwСмонтировать файловую систему для чтения и для записи (по умолчанию)devФС может содержать файлы блочных и символьных устройств. Они интерпретируются как специальные файлыexecФайлы на ФС могут быть исполняемымиsuidРазрешить использование битов SUID и SGIDuserРазрешить непривилегированному пользователю монтировать и размонтировать данную файловую систему. Это значение влечет за собой noexec, nosuid и nodev, если после него явно не указано exec, suid или devnoauto nodev noexec nosuid nouserЗначения, противоположные соответствующим без «no»defaultsУстановки по умолчанию: rw, suid, dev, exec, auto, nouser, asynccodepage=&lt;значение&gt;Интерпретировать символы в именах файлов согласно кодовой страницеiocharset=&lt;значение&gt;Выводить символы в именах файлов согласно набору символов
   Программа установки создала файл/etc/fstab,в котором перечислены все ваши Linux-разделы (корневой, swap и, если вы послушались п.1.3.4,/home).Теперь нужно сделать так, чтобы из-под Linux были видны данные на ваших Windows-разделах. Проверьте, поддерживает ли ваше ядро типы ФС на Windows-разделах (cat /proc/filesystems,в выводе команды должны присутствовать словаvfatи/илиntfs).Обычно ядро, поставляемое с дистрибутивом, собрано без поддержки NTFS — если ваш Windows-раздел отформатирован с этим типом, то вам придется либо пересобрать ядро, либо,что гораздо проще, конвертировать раздел в тип FAT32.
   Итак, после всех этих проверок я вписал в файл/etc/fstabстроку:
   /dev/hda6 /mnt/disk_e vfat rw,codepage=866,iocharset=utf8
   …и получил каталог/mnt/disk_e,всем файлам в котором приписан в качестве владельца root, а в качестве прав доступа — rwx-rxr-x. Если вас такой режим доступа не устраивает и хочется иметь право писать в этот каталог от имени непривилегированного пользователя, прочитайте на man-странице командыmountоб опцияхuid,gidиumask.
   Глава 3
   Работаем в командной строке
   3.1.Как устроен Linux: ядро и процессы
   Главная, постоянно находящаяся в оперативной памяти, часть ОС Linux называется ядром (Kernel). Ядро ОС обрабатывает прерывания от устройств, выполняет запросы системныхпроцессов и пользовательских приложений, распределяет виртуальную память, создает и уничтожает процессы, обеспечивает многозадачность посредством переключениямежду ними, содержит драйверы устройств, обслуживает файловую систему (см. рис. 3.1). [Картинка: img_32.jpeg] 
   Рис. 3.1.Устройство ОС Linux
   Пользовательские процессы не могут непосредственно, например, порождать другие процессы, производить чтение или запись на диск, выводить данные на экран или создавать гнездо (socket)для обмена по сети. Для выполнения этих действий они должны воспользоваться сервисами ядра. Обращения за такими услугами называются системными вызовами.
   Начальная загрузка системы состоит в том, что файл с образом ядра считывается в оперативную память, начиная с нулевого адреса. Этот файл находится в каталоге/bootи называется vmlinuz-x.y.z, где x.y.z — это номер версии ядра. На текущий момент большинство дистрибутивов основано на ядре версии 2.4, хотя уже вышло ядро 2.6 (Fedora Core 3) и кое-где еще встречается версия 2.2.Примечание
   По соглашению разработчиков ядра, все ветви с четным номером (2.2, 2.4 и т.д.) считаются стабильными и рекомендуются для широкого использования, а на ветвях с нечетным номером испытываются новые идеи, Линус Торвальдс предложил распространить эту схему нумерации и на третью цифру версии: в ядра с нечетными номерами добавлять новые функции, а в четных — только исправлять обнаруженные ошибки.
   В UNIX-подобных системах в отличие от других ОС ядро минимизировано и не выполняет ни одной функции, служащей непосредственно пользователю. Для этой цели применяются многочисленные утилиты, выступающие в качестве посредников между пользователем и ядром. Только в комплекте с ними ядро образует полноценную операционную систему.
   Этих компонент ОС Линус Торвальдс не создавал: они поступили из проекта GNU (http://www.gnu.org),участники которого с 1984 года работают над созданием полноценной UNIX-подобной ОС, целиком состоящей из свободно распространяемого программного обеспечения. К 1991 году им не хватало только ядра, и эту-то прореху и заполнил Торвальдс. Так что ОС, которой посвящена эта книга, правильнее называть не Linux, а «операционной системой GNU, основанной на ядре Linux», или просто GNU/Linux.
   Итак, ядро обслуживает запросы процессов. Что же такое процесс? Это понятие является базовым в UNIX-подобных системах. Процесс можно представить себе как виртуальную машину, отданную в распоряжение одной задачи. Каждый процесс считает, что он на машине один и может распоряжаться всеми ее ресурсами. На самом же деле процессы надежно изолированы друг от друга, так что крушение одного не может повредить всей системе (сколько раз вы наблюдали в Windows, как сбой одной программы приводил к общему зависанию?).
   Каждый процесс выполняется в собственной виртуальной памяти (см, рис. 3.2), в которую никакой другой процесс вмешаться не может. Этим и обеспечивается устойчивость всей системы. [Картинка: img_33.jpeg] 
   Рис. 3.2.Виртуальная память процесса
   Напоминаю, что такое виртуальная память. Каждому процессу разрешено считать, что его адреса начинаются с нулевого адреса и от него наращиваются. Таким образом, в 32-разрядной ОС процесс может адресовать 4 гигабайта оперативной памяти. Механизм виртуальной памяти позволяет процессу думать, что именно столько ему и выделено, хотя физически объем ОЗУ вашей машины — какие-то жалкие 256 Мбайт. Недостающую память заменяет жесткий диск путем записи временно не используемых страниц памяти в раздел подкачки (свопинга).
   Разделяемость библиотек между процессами обеспечивается тем, что их код и статические данные отображаются на один и тот же участок физической оперативной памяти.
   3.2.Жизнь процессаТаблица процессов
   С точки зрения ядра процесс представляет собой запись в таблице процессов. Эта запись содержит данные, существующие в течение всего времени жизни процесса, и сведения о его состоянии. Размер таблицы процессов позволяет запускать несколько сотен процессов одновременно. Другая важная информация о процессе — например, таблица всех открытых процессом файлов — хранится в его адресном пространстве. Запись в таблице процессов и пространство процесса вместе составляют контекст, или окружение, процесса. В него входят:
   ? PID— идентификатор процесса. Он принудительно назначается планировщиком при запуске процесса.
   ? PPID— идентификатор родительского процесса (о порождении процессов — дальше в этом же параграфе).
   ? TTY— имя управляющего терминала (терминал, с которого запущен процесс).
   ? WD— текущий каталог процесса, от которого отсчитываются относительные пути.
   ? RID,RGID— реальные ID и групповой ID пользователя, запустившего процесс.
   ? EUID,EGID— эффективные ID и GID: см. п.2.1.4.8.
   ? NICE— показатель уступчивости. Процессы выполняются в режиме разделения времени, то есть время центрального процессора делится между готовыми к выполнению процессами с учетом их приоритета. Чем выше показатель уступчивости, тем ниже приоритет.
   ? Переменные окружения.Системные вызовы fork() и exec() или как размножаются процессы
   Каждый процесс порождается другим процессом, использующим для этого системный вызовfork().Таким образом, структура процессов, подобно файловой системе, древовидна. Корнем этого дерева служитinit— процесс инициализации системы. Он запускается ядром первым, получает идентификатор 1 и порождает еще несколько процессов (сколько и каких, можно узнать из его конфигурационного файла/etc/inittab),которые, в свою очередь, при участии пользователя порождают другие процессы.
   В результате системного вызоваfork()родительский процесс полностью копирует свое окружение, включая адресное пространство, в дочерний, так что в момент рождения дочерний процесс отличается только своим ID. Потом дочерний процесс с помощью вызоваexec()загружает в свое адресное пространство какой-нибудь исполняемый файл и начинает исполнять содержащуюся в нем программу.
   Может случиться и так, что процесс выполняет вызовexec()безfork():тогда не возникает нового процесса, но в старом начинает выполняться другая программа. Например, программаloginвыполняется с привилегиями суперпользователя, поскольку ей нужен доступ к файлу паролей. Проверив пароль, она устанавливает себе права зарегистрировавшегося пользователя и выполняет вызовexec(),замещая свой код кодом командной оболочки. После этого из командной оболочки изменить свои привилегии обратно на root нельзя, потому что кода программыloginв текущем процессе уже нет. [Картинка: img_34.jpeg] 
   Рис. 3.3.Как размножаются процессы
   Каждый процесс, завершившись, возвращает родительскому процессу какое-то значение, называемое кодом завершения или кодом возврата. По соглашению разработчиков, нулевой код возврата означает успешное завершение, а ненулевые — разнообразные ошибки. Процесс-родитель может приостановить свое выполнение до завершения потомка и выполнить разные действия в зависимости от возвращенного дочерним процессом значения, а может и не делать этого.Снимок протекающих в системе процессов — команда ps
   Моментальный снимок протекающих в системе процессов можно посмотреть с помощью командыps (process status).Без аргументов она покажет список процессов, связанных с текущей консолью (или виртуальным терминалом). Список возможных ключей команды можно, как обычно, получить по командеps --help.Вот некоторые полезные из них:
   ? -p&lt;список_PID&gt;:только процессы с указанными ID;
   ? -u&lt;список_USERID&gt;:только запущенные указанными пользователями;
   ? -е:все процессы в системе;
   ? -f:полная форма вывода;
   ? -Н:вывод иерархии процессов в форме дерева. [Картинка: img_35.jpeg] 
   Рис. 3.4.Фрагмент иерархии процессовДинамика процессов — команда top
   Представление о динамике процессов дает командаtop.Она выводит список процессов, отсортированный по количеству запятой памяти или использованного процессорного времени, и обновляет его через указанные промежутки времени (по умолчанию через каждые 3 секунды).Категории процессов
   Процессы делятся на три категории:
   ? Системные.Они порождаются ядром особым образом в процессе загрузки и выполняют системные функции (например, планирование процессов или смену страниц виртуальной памяти). Выполняемая ими программа берется не из исполняемого файла, а является частью ядра.
   ? Пользовательские.Как правило, они порождаются во время сеанса работы пользователя и связаны с терминалом. Если пользовательский процесс работает в интерактивном режиме, то он захватывает терминал в монопольное владение и, пока он не завершится, пользователь не имеет доступа к командной строке на этом терминале. Пользовательские процессы могут работать также в фоновом режиме, освободив командную строку.
   ? Демоны.Запускаются после инициализации ядра. Выполняются в фоновом режиме, не связаны ни с одним пользователем, обеспечивают работу различных служб (например, управление сетью). Главным демоном считаетсяinit— процесс инициализации системы.Примечание
   Название «демон» (daemon)не имеет ничего общего с потусторонними существами: это просто сокращение от Disk And Execution MONitor.
   3.3.Взаимодействие процессов
   Из всех средств межпроцессного взаимодействия, которыми так богаты UNIX-подобные ОС, в этой главе мы рассмотрим только конвейеры и сигналы.
   3.3.1.Конвейер (pipe)
   В главе 2 вы познакомились с командой-фильтромmore,вызываемой так:
   &lt;команда_выводящая_много_строк&gt; | more
   Символ «|» — это и есть конвейер. Его можно понимать как канал, в который один процесс может только писать, а другой — только читать из него. Выборка и помещение информации в такой канал происходит в порядке FIFO (First In/First Out).
   Посредством конвейера вывод одной команды подается на вход другой. Это одно из мощнейших средств UNIX, позволяющее комбинировать из простых команд длинные и изощренные цепочки обработки данных.
   Например, я хочу узнать, осталась ли у меня еще свободная виртуальная консоль, чтобы зарегистрироваться там и спросить справку по какой-то команде, не прерывая процессов, протекающих на других консолях. Я знаю, что виртуальную консоль обслуживает программаmingetty,которая после регистрации на этой консоли замещает свой код на код командной оболочки. Значит, мне нужно подсчитать количество процессовmingetty.Есть командаwc (word count),умеющая подсчитывать число строк, слов или байтов в файле. Есть командаgrep,умеющая выбирать из файла строки, содержащие указанный фрагмент текста. Соединяю их конвейером:
   $ ps -е | grep mingetty | wc -l
   3.3.2.Сигналы
   Механизм сигналов — это средство, позволяющее сообщать процессам о некоторых событиях в системе, а процессу-получателю — должным образом на эти сообщения реагировать.Послать сигнал может сам процесс (например, при попытке деления на ноль), ядро (при сбое оборудования), пользователь или другой процесс (требуя прервать выполнение задачи).
   Всего в Linux 63 сигнала, обозначаемых своими номерами или символическими именами. Имена всех сигналов начинаются с SIG, и эту приставку часто опускают: так, сигнал, требующий прекратить выполнение процесса, называется SIGKILL, или KILL, или сигнал 9.
   Получив сигнал, процесс может: игнорировать его; вызвать для обработки установленную по умолчанию функцию; вызвать собственный обработчик (перехватить сигнал). Некоторые сигналы (например, KILL) перехватить или игнорировать невозможно.
   Пользователь может послать сигнал процессу с идентификатором PID командой
   $ kill [-s&lt;сигнал&gt;]&lt;PID&gt;
   где&lt;сигнал&gt;— это номер или символическое имя.
   Несколько часто встречающихся сигналов перечислены в таблице 3.1. Полный список можно получить по командеkill -l (list).

   Сигналы Linux Таблица 3.1№ИмяНазначениеРеакция процесса-получателя1HUPHangup— отбойДемоны перечитывают свои конфигурационные файлы2INTInterruptПрекратить выполнение (перехватывается)3QUITСильнее, чем INTто же4ILLIllegal instruction.Программная ошибкаОбработать ошибку. По умолчанию — прекратить выполнение8FPEFloating point exceptionВычислительная ошибка (деление на ноль)Обработать ошибку. По умолчанию — прекратить выполнение9KILLУбить процессНемедленно прекратить выполнение. Не перехватывается11SEGVSegmentation violation.Попытка доступа к чужой области памятиОбработать ошибку. По умолчанию — прекратить выполнение13PIPEНет процесса, читающего из конвейераОбработать ошибку15TERMTermination.Завершить процессКорректно завершить выполнение. Перехватывается17CHLDЗавершился дочерний процессПринять возвращенное им значение
   Некоторые сигналы посылаются по нажатии комбинации клавиш. Так, Ctrl+C посылает сигнал INT, a Ctrl+\ (обратный слэш) — сигнал QUIT. Получает эти сигналы тот процесс, который сейчас занимает консоль — например, ожидает вашего ввода.
   Командаkillносит такое убийственное название потому, что чаще всего используется для принудительного завершения процессов, вышедших из-под контроля, забирающих много ресурсов или просто повисших. По умолчанию она посылает сигнал TERM. Он отличается от сигнала KILL тем, что приказывает процессу завершиться аккуратно, закрыв открытые им файлы, удалив временные и т.п. Сигнал же KILL действует на процесс как выстрел в голову.
   Понятно, что для того, чтобы прервать выполнение процесса, нужно быть его хозяином или иметь привилегии суперпользователя.
   3.4.Командная оболочка. Bash
   Важнейшим из пользовательских процессов является командная оболочка (она же командный интерпретатор, или просто shell). Именно она обеспечивает взаимодействие пользователя с системой в текстовом режиме, позволяя вводить команды. Именно она запускается, когда вы регистрируетесь на текстовой консоли, и предоставляет вам интерфейс командной строки.
   Не нужно, увлекшись удобствами графического интерфейса, недооценивать командную строку. Во-первых, многие административные задачи могут быть выполнены только оттуда; во-вторых, командная строка — самое удобное средство автоматизации рутинных процедур.
   Командой в Linux считается все, что может быть исполнено: исполняемые файлы, встроенные команды оболочки, псевдонимы команд, пользовательские функции, файлы сценариев (скрипты) — заранее подготовленные последовательности команд в текстовом виде. До сих пор, приводя примеры команд, я не различал их по происхождению, и дальше не собираюсь делать этого, кроме особых случаев.
   Оболочка принимает вводимые пользователем команды, обрабатывает, если нужно, их аргументы, отправляет команды на выполнение, принимает возвращаемые ими значения и выполняет определенные действия в зависимости от этих значений. Кроме того, в оболочку встроен язык программирования (командный язык), позволяющий писать сложныеразветвленные командные сценарии. Именно командный язык отличает разные оболочки друг от друга, и именно из него исходят пользователи, выбирая любимую и нелюбимую оболочки.
   Для Linux разработано много командных интерпретаторов. Вот несколько из них:
   shBourne shell,оболочка Борна, стандарт для многих UNIX-подобных систем;
   bash Bourne Again shell,«еще одна оболочка Борна»;
   cshС shell,оболочка Си: синтаксис ее командного языка похож на синтаксис языка С;
   tcsh tinyС shell,минимальная оболочка Си;
   pdksh public domain Korn shell,общедоступная оболочка Корна;
   sashstand-alone shell,автономная оболочка, может быть использована в случае, когда программные библиотеки недоступны.
   Список всех установленных в системе программ-оболочек находится в файле/etc/shells.У меня он выглядит так:
   /bin/sh
   /bin/bash
   /sbin/nologin #это "оболочка" для тех,
                 # кому запрещен вход в систему
   /bin/ash
   /bin/bsh
   /bin/ksh
   /usr/bin/ksh
   /usr/bin/pdksh
   /bin/tcsh
   /bin/csh
   Начальная оболочка для каждого пользователя, запускаемая для него при регистрации в системе, указывается в файле/etc/passwd:
   $ grep den /etc/passwd #выбрать из файла строки,
                          # содержащие подстроку den
   den:x:501:501:Denis:/home/den:/bin/bash
   В дальнейшем вы можете сменить текущую ободочку на любую из установленных (точнее, войти в подоболочку). Чтобы выйти из нее и вернуться в родительскую оболочку, введите командуexit.В начальной оболочке эта команда завершает сеанс работы.
   В любой оболочке можно запускать командные сценарии, состоящие из команд другой оболочки: первая строка каждого сценария содержит указание на то, в какой оболочкеего следует выполнять, и текущая оболочка запускает для него указанную как дочерний процесс.
   По умолчанию новому пользователю назначается оболочкаbash.Это прекрасная оболочка, включающая много усовершенствований и лучших свойств других ободочек, и менять ее я не рекомендую. В дальнейшем, говоря «оболочка», я будуиметь в виду именноbash.
   3.4.1.Встроенные команды
   Список встроенных команд оболочкиbashможно получить по командеhelpили найти на man-странице в секции SHELL BUILTIN COMMANDS. Напоминаю, что поиск в выводе команды man выполняется командой/&lt;образец&gt;&lt;Ввод&gt;,а поиск следующего вхождения образца — по нажатии клавиши&lt;n&gt;.
   Справку по команде, имя которой вы знаете, можно получить командойhelp&lt;имя&gt;.
   Вот несколько полезных встроенных команд:
   ? alias&lt;псевдоним&gt;&lt;длинная команда с аргументами&gt;— назначение псевдонима. Без аргументов выводит список всех имеющихся псевдонимов. Обратите внимание, что у пользователя root командаrmсделана псевдонимом для «rm -i», чтобы он не забыл воспользоваться ключом -i (см.п.2.1.4.3). Вы тоже можете назначить псевдоним для опасной командыrisk,создав сценарий, который сначала будет спрашивать «а вы уверены?», и только при положительном ответе запускатьriskна выполнение. Дайте этому сценарию имяrisk,а внутри него ссылайтесь на настоящую командуriskпо ее полному пути. Удалить псевдоним из списка можно командойunalias.
   ? echo [аргументы]— вывод аргументов на экран. Полезно, если нужно выполнить подстановку (п.3.4.4) и посмотреть, что получится.
   ? enable&lt;имя_команды&gt;— заставляет оболочку вместо встроенной команды выполнить исполняемый файл с таким же именем. Полезно, если у вас есть собственный сценарий по имени, например, echo.
   ? eval [аргументы]— конструирование команды на лету, из указанных аргументов, и отправка ее на выполнение.
   ? let&lt;переменная&gt;=&lt;арифметическое выражение&gt;— вычисление выражений. Так, команда var= 1 + 2 присвоит переменной var (см. п.3.4.3) значение «1 + 2», а команда let var=1+2 — значение «3».
   ? source&lt;файл&gt;— прочитать и выполнить команды, содержащиеся в файле. Применяется для определения пользовательских переменных и функций (п.3.4.3).
   Другие встроенные команды служат инструкциями командного языкаbash.
   3.4.2.История команд
   Оболочка предлагает вам много возможностей для облегчения ввода команд и редактирования командной строки. Помимо функции автозаполнения, с которой вы познакомились в п.1.1.4.7,bashсодержит механизм командной истории. Суть его в том, что вводимые вами команды (по умолчанию 1000) запоминаются и доступны для повторного вызова — без изменений или с ними.
   Командаhistoryбез аргументов выводит всю историю, нумеруя при этом команды в порядке их ввода.
   Если вас интересуют только последние несколько команд:
   $ history 23 #показать последние 23 команды
   Если вас интересуют все команды, имеющие отношение к монтированию каталогаpublic:
   $ history | grep mount | grep public
   #еще один пример конвейера
   Номера команд выводятся для того, чтобы вы могли снова ввести эту команду, набрав
   $ !&lt;номер&gt;
   или
   $ !! #запускает последнюю из введенных команд
   или
   $ !&lt;первые_буквы&gt; #запускает последнюю из команд,
   #начинающихся с этих букв.
   Стрелки «вверх» и «вниз» перемещают по командной истории, не отправляя команду на выполнение, а вводя ее в командную строку для редактирования.
   Последнюю команду может для вас отредактировать сама оболочка. Для этого вместо команды введите:
   $ ^что_заменить^чем_заменить
   Например, вы запросили справку по команде оболочкеbash:man bash.Если сразу после этого вы хотите посмотреть справку по оболочкеcsh,можете вместоman cshнабрать
   $ ^ba^c
   Помните, что замене подлежит первое вхождение подстроки «что_заменить».
   Если вы хотите не изменить, а дополнить последнюю команду (например, пропустить ее вывод через фильтрmore),введите
   $ !! | more
   3.4.3.ПеременныеОписание и использование переменных
   Как любой язык программирования, командный языкbashподдерживает переменные. Тип их — строковый. Оператор присваивания выглядит так:
   $&lt;имя_переменной&gt;=&lt;значение&gt;
   Имя должно начинаться с буквы и может состоять из латинских букв, цифр, знака подчеркивания. Если значение переменной содержит специальные символы, их нужно экранировать кавычками или обратным слэшем (см. п. 2.1.1).
   Операция подстановки значения переменной обозначается символом $ (не путайте с приглашениемbash).Вывести значение переменной можно командойecho:
   $ cwd=/home/den/MyDownloads/packages
   $ echo cwd #выводит имя переменной
   cwd
   $ echo $cwd #выводит значение переменной
   /home/den/MyDownloads/packages
   Установленные таким образом переменные доступны только встроенным командамbash.Чтобы они стали доступны дочерним процессам (программам и командным сценариям, запускаемым из-подbash),их нужно поместить в окружениеbash.Делается это командойexport:
   $ export HELLO="Hello from environment!" #пробел нужно экранировать
   Чтобы почувствовать разницу, создайте простейший командный сценарий, выводящий значения двух переменных. Для записи сценария можно создать пустой файл и открыть его в каком-нибудь ASCII-редакторе, а можно вспомнить п.2.1.4 и воспользоваться командойcat:
   $ cat&gt; myscript
   echo Env variable: $HELLO
   echo Local variable: $hello #помните о разнице в регистре?
   #Это другая переменная.
   ^D
   $
   Комбинация клавиш Ctrl+D завершает ввод и закрывает файл, и вы снова видите приглашение оболочки.
   Получившийся файл сценария нужно сделать исполняемым (п.2.1.4):
   $ chmodа+x myscript
   Теперь осталось определить переменную hello и запустить сценарий:
   $ hello="Hello from local"
   $ echo $hello
   Hello from local
   $ ./myscript
   Env variable: Hello from environment!
   Local variable:
   $Переменные окружения
   Когда оболочка начинает работу, она устанавливает для себя несколько переменных окружения. Имена их стандартны. Программы и сценарии могут запросить их значения вместо того, чтобы пытаться выяснить нужную им информацию самостоятельно.
   Несколько таких переменных перечислены в таблице 3.2.

   Переменные окруженияbashТаблица 3.2ИмяНазначениеBASH_VERSIONВерсия оболочкиUSERИмя. под которым вы зарегистрировалисьUID, EUIDРеальный и эффективный userIDHOMEПуть к вашему домашнему каталогуHOSTNAMEИмя вашего компьютераHOSTTYPEТип процессора (i386 или другой)OSTYPEОперационная система (linux-gnu)HISTFILE, HISTSIZEРасположение и размер файла истории командLANGЯзык текущего сеансаLINES, COLUMNSЧисло строк и столбцов на экране текстовой консолиPS1, PS2, PS3, PS4Переменные, определяющие вид приглашения оболочкиPATHПорядок просмотра каталогов в поисках исполняемого файла с заданным вами именем, когда полный путь к нему не указан
   Чтобы просмотреть значения всех переменных текущего сеанса, как определенных вами, так и переменных окружения, введите командуset.
   Обратите внимание на переменную PATH: среди каталогов, в которыхbashищет исполняемый файл, нет текущего. Поэтому в предыдущем примере, если бы вы попытались исполнить сценарий командойmyscript,оболочка ответила бы «Command not found». Нужно было указать путь к исполняемому файлу, и мы указали его относительным способом, считая от текущего каталога:./myscript.
   Переменная PS1 у меня выглядит так:[\u@\h \W]\$.Это значит, что приглашение оболочки у меня формируется из регистрационного имени (username),имени машины (hostname),текущего каталога (working dir)и символа $. Я могу и изменить его:
   [den@dhsi.labs ~]$ pssave=$PS1 #сохраняю старое значение
   [den@dhsilabs PS1="\W&gt;"
   ~&gt; #новое приглашение состоит из имени текущего каталога и символа&gt;
   -&gt; cd My* MyDownloads&gt;
   MyDownloads&gt; PS1=$pssave #поиграли, и хватит
   [den@dhsilabs MyDownloads]$
   Удалить переменную можно командой unset&lt;имя&gt;.Быстрая смена каталога
   Переменная CDPATH задает список каталогов, в которых будет происходить поиск нужного подкаталога при смене каталога (использовании командыcd).Проще всего пояснить, как работает CDPATH, на примере. Пусть в моем каталоге/home/denis/books/linux-serverесть подкаталогиchapter1 ... chapter20.Если мне нужно перейти в подкаталогchapter2,то я могу сэкономить на наборе имени его родительского каталога, внеся это имя в переменную CDPATH:
   $ export CDPATH=:.:/home/denis/books/linux-server
   Теперь по командеcd chapter2я попаду в каталог/home/denis/books/linux-server/chapter2из любого места файловой системы, если подкаталогаchapter2нет в текущем каталоге.Настройка командной строки. Утилита tput
   Наверное, многим хочется, чтобы их компьютер не был похож на компьютер коллеги за соседним столом. Кто-то меняет темы, кто-то — обои. Мы попробуем изменить командную строку текстовой консоли. Рассмотрим сценарий, выводящий текущий каталог в правом верхнем углу — обычно этот угол при выводе текста остается свободным. Для чего? А просто так — чтобы было не как у всех.
   Для манипуляции с курсором и цветом букв и фона используется утилитаtput.В п.2.1.4 вы узнали, как применить ее для восстановления «сбитой» консоли, а сейчас посмотрите на то, что она умеет еще. А потом прочитайте man-страницу.
   Листинг 3.1. Демонстрация возможностей утилиты tput
   #!/bin/bash

   function prompt_command {
    # сохраняем текущую позицию курсора
    tput sc
    # вычисляем длину, необходимую для вывода текущего каталога
    # текущий каталог можно узнать с помощью команды pwd
    let backwash=$(tput cols)-$(echo $(pwd) | wc -m)-2
    # позиционируем курсор Y=0, X=длина
    tput cup 0 ${backwash}
    # установка цвета букв, начертание — жирное
    tput setaf 4 ; tput bold
    # выводим полный путь в квадратных скобках
    echo -n " ["
    # устанавливаем цвет
    tput setaf 6
    # отображаем путь
    echo -n "$(pwd)"
    # устанавливаем цвет для закрывающей скобки
    tput setaf 4 ; tput bold
    # отображаем ]
    echo -n "]"
    # возвращаем курсор в исходную позицию
    tput rc
   }

   PROMРТ_СОММAND=prompt_соmmand

   GREEN="\[$(tput setaf 2 ; tput bold)\]"
   WHITE="\[$(tput setaf 7 ; tput bold)\]"
   NO_COLOUR="\[$(tput sgr0)\]"

   case $TERM in
   xterm*|rxvt*)
    TITLEBAR='\[\033]0;\u@\h \007\]'
    ;;
   *)
    TITLEBAR=""
    ;;
   esac

   PS1="${TITLEBAR}\
    $GREEN\u@\h \
    $WHITE\$$NO_COLOUR "
   PS2='&gt; '
   PS4='+ '
   Команды утилитыtput:
   tput setaf [1-7]установка цвета символов с использованием ANSI ESC-последовательности;
   tput setab [1-7]установка цвета фона;
   tput revобратить цвета фона и переднего плана;
   tput boldустановка жирного начертания;
   tput dimотключение жирного начертания;
   tput smulустановка подчеркнутого начертания;
   tput rmulотключение подчеркнутого начертания.
   3.4.4.Подстановка переменных и команд
   Переменные можно использовать как имена, части имен или аргументы команд. Перед выполнением команды оболочка заменит имена переменных их значениями. Например, после того, как мы присвоили переменной cwd значение пути к каталогу, можно перейти в этот каталог по команде
   $ cd $cwd
   Вывести на экран файл README из этого каталога можно, введя команду
   $ more ${cwd}/README
   Брать имя переменной в скобки необязательно, но удобно, если нужно отделить имя переменной от предшествующих ему или следующих за ним символов.
   Мощным инструментом оболочкиbashявляется подстановка команд, то есть замена имени команды на результат ее выполнения. Так, считая/home/den/МуDownloads/packagesтекущим каталогом, мы могли бы присвоить переменной cwd то же самое значение проще:
   $ cwd=`pwd` #напоминаю, что команда pwd возвращает
               # путь к текущему каталогу
   Можно подставлять значения не только определенных вами переменных, но и переменных окружения. Так, чтобы поэкранно вывести список всех процессов, запущенных от вашего имени, введите:
   $ ps -ef | grep $USER | less
   3.4.5.Шаблоны имен файлов
   Этот механизм позволяет не перечислять похоже выглядящие имена файлов и каталогов, а указать на целую группу имен, задав краткий образец. Перед отправкой команды на выполнение оболочка раскрывает шаблон, то есть заменяет образец всеми именами, подходящими под этот образец, и выполняет команду для каждого файла или каталога из этой группы. Шаблоны указываются с помощью специальных символов, перечисленных в таблице 3.3. Символы шаблона можно комбинировать в одной команде.

   Символы шаблонов Таблица 3.3СимволЗначениеПример*Произвольная строка символов, в том числе пустая~/*.png— все файлы в домашнем каталоге с расширением png; Glava* — файлы Glava, Glava03 и Glava.old?Любой одиночный символGlava??— файлы Glava03 и GlavaXZ, но не Glava и не Glava.old[m,M,x]Любой символ ив перечисленных в скобкахGlava0[3,8]— файлы Glava03 и Glava08, Glava?[3,8] — файлы Glava03, Glava08, Glava13, Glava18, Glava23[a-nA-N]Любой символ ив указанных интерваловGlava0[2-4,9]— Glava02, Glava03, Glava04, Glava09[^a-n,x,y]Любой символ, на указанный в скобкахGlava[^0]*— все главы, начиная с 11
   Символы шаблона можно использовать и как обычные символы в именах файлов. Тогда их нужно экранировать, чтобы оболочка не приступила к их раскрытию:
   $ touch \* #создаст файл с именем "*". Только не
              # удаляйте его потом командой rm * !
   $ rm Glava0\[3\,8\] #удалит файл с именем Glava0[3,8],
                       # а не Glava03 и Glava08.
   3.4.6.Потоки ввода-вывода
   Как я уже сказал, каждому процессу сопоставлена таблица открытых им файлов. Три первых позиции в этой таблице заняты всегда: каждый процесс открывает потоки (помните, что в UNIX файл — это и есть поток данных?) для ввода и вывода данных, а также вывода сообщений об ошибках и другой диагностической информации. Эти потоки:
   ? 0 — стандартный ввод (stdin),
   ? 1 — стандартный вывод (stdout),
   ? 2 — стандартный поток сообщений об ошибках (stderr).
   Ссылаться на эти потоки можно по ихфайловым дескрипторам. 0, 1и 2 — это и есть такие дескрипторы.
   По умолчанию потоки ввода-вывода связываются с консолью, с которой запущен процесс: стандартный ввод — с клавиатурой, другие два потока — с экраном (рис. 3.5, потокиcmd1).
   Все потоки можно перенаправить в другой файл. Это может быть файл на диске, файл устройства (например, принтер или/dev/null)или стандартный поток другого процесса.
   Для перенаправления стандартного вывода команды используется символ&gt; («больше»). Если местом назначения служит файл, то можно его не перезаписывать, а присоединить (append)выводимые данные в его конец. Для такого перенаправления применяется символ&gt;&gt;.
   Стандартный ввод перенаправляется символом&lt; («меньше»).
   Для перенаправления стандартного потока ошибок используется конструкция2&gt;.Чтобы присоединитьstderrкstdoutи перенаправить их вместе, пользуйтесь переадресацией2&gt;&1.
   Для направления стандартного вывода одной команды на стандартный ввод другой применяется символ|— уже знакомый вам конвейер.
   Ситуация, изображенная на рис. 3.5, могла бы сложиться после выполнения следующих команд:
   cmd2&lt; file1.txt | cmd3 2&gt;&1&gt; file2.txt
   cmd4 2&gt; /dev/null | tee file3.txt file4.txt file5.txt [Картинка: img_36.jpeg] 
   Рис. 3.5.Перенаправление потоков ввода-вывода
   Команда-фильтрteeкопирует данные со своего стандартного ввода в стандартный вывод, дублируя их при этом в указанные ей файлы.
   3.4.7.Группировка команд
   Кроме конвейеров, команды можно соединять в списки. Простейший вид списка — несколько команд, разделенных точкой с запятой:
   $ lpr myfile.txt ; lpq
   Команды в таком списке выполняются последовательно: сначала будет выполнена команда постановки задания в очередь печати, а потом проверено состояние принтера. Оболочка ждет завершения каждой команды, чтобы отправить на выполнение следующую (синхронный режим).
   В списки можно группировать не только одиночные команды, но и конвейеры:
   $ ps -ef | head -n 1; ps -ef | grep httpd

   UID    PID   PPID  С STIME TTY TIME     CMD
   root   13565 1     0 13:11 ?   00:00:00 /usr/local/sbin/httpd
   nobody 13566 13565 0 13:11 ?   00:00:00 /usr/local/sbin/httpd
   nobody 13567 13565 0 13:11 ?   00:00:00 /usr/local/sbin/httpd
   nobody 13642 13565 0 13:16 ?   00:00:00 /usr/local/sbin/httpd
   Первый конвейер вырезает из списка процессов заголовок, а второй — информацию о демонеhttpd.
   Если требуется запустить команду на заднем плане и не ждать ее выполнения (асинхронный режим), то нужно завершить ее управляющим оператором&:
   $ du --human-readable --total /home&gt; diakusage.txt&
   Командаduсообщает, сколько места на диске занято файлами в указанном каталоге. Обратите внимание на ключи: их имена предваряются не одним минусом, а двумя. Большинство команд поддерживает как короткие однобуквенные ключи, так и длинные — с осмысленными, легко запоминаемыми именами. Напоминаю, что список и значения ключей командыcmdможно получить, выполнив ее с ключом--helpили--usage.
   Конвейеры (или одиночные команды) в списке можно соединять управляющими операторами&&и||,получая «список И» или «список ИЛИ» соответственно:
   cmd1&& cmd2 cmd3 || cmd4
   Вторая команда в «списке И» будет выполнена только в случае успешного завершения первой. Типичный пример — создание каталога и переход в него:
   $ mkdir mydir&& cd mydir
   Вторая команда в «списке ИЛИ» будет выполнена только в случае неуспешного завершения первой (возврата ею ненулевого значения):
   $ my_command || echo "Команда my_command не найдена" | mail den
   Вторая команда (конвейер) в этом примере формирует и посылает письмо с отчетом о неуспехе пользователю den.
   Чтобы перенаправить в файл вывод всех команд из списка, нужно взять весь список в круглые скобки:
   $ ( date; free; who; )&gt; logfile
   Список, взятый в круглые скобки, выполняется в дочерней оболочке, имеющей собственные локальные переменные и текущий каталог:
   $ pwd; ( cd / tmp ; pwd ) ; pwd;
   /home/den
   /tmp
   /home/den
   $
   Если нужно часто выполнять одну и ту же последовательность команд, можно оформить ее как функцию:
   $ function morning_report {
   &gt; date;
   &gt; free;
   &gt; W;
   &gt; }
   $ morning_report | mail root
   Имена и область видимости функций подчиняются тем же правилам, что и для переменных. Нельзя определять функцию и переменную с одинаковыми именами.
   Определенные вами переменные и функции действительны только для текущего сеанса работы в оболочкеbash.Чтобы воспользоваться ими в следующем сеансе, запишите их в текстовый файл, а когда они понадобятся, загрузите этот файл в память командного интерпретатора встроенной командойsource:
   $ cat&gt; foo
   myvar="Моя переменная"
   function myfun {
    echo $myvar
   }
   ^D
   $ source foo
   $ myfun
   Моя переменная
   $
   Командаsourceвыполняет инструкции, содержащиеся в файле, в текущей оболочке в отличие от исполнения файла, содержащего сценарий: тот выполняется в дочерней оболочке, и определенные в ней переменные и функции для родительской оболочки невидимы. Чтобы заметить разницу, удалите переменнуюmyvarи функциюmyfunиз памяти оболочки командойunset,сделайте файлfooисполняемым командойchmod (п.3.4.3) и исполните его. Убедитесь, что после его выполнения переменнаяmyvarи функцияmyfunостались не определены.
   3.4.8.Инициализационные файлы bash
   Начальные значения переменных окружения становятся известны командному интерпретаторуbashиз инициализационных файлов, которые он прочитывает сразу после своего запуска. Эти файлы называются.bash_profileи.bashrc (в порядке чтения оболочкой) и берутся из домашнего каталога запустившего оболочку пользователя.
   Команды, присутствующие в этих файлах по умолчанию, только прочитывают общесистемный файл настроек/etc/bashrc.Вы можете добавить к ним свои личные настройки, определив нужные вам переменные, функции и псевдонимы.
   При завершении сеанса работы с оболочкой выполняются команды в файле~/.bash_logout.Туда вы тоже можете добавить свои команды: например, зафиксировать время окончания своего сеанса в файле или в письме другому пользователю.
   Команду установки переменной CDPATH, рассмотренной в п.3.4.3, имеет смысл добавить в.bash_profile,чтобы не пришлось вводить ее вручную в начале каждого сеанса работы вbash.
   Глава 4
   Рабочее место пользователя
   Если вы